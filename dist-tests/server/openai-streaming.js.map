{"version":3,"file":"openai-streaming.js","sourceRoot":"","sources":["../../server/openai-streaming.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * OpenAI Streaming Audio Transcription Service\n * \n * Provides real-time transcription for audio streams using OpenAI's Whisper model.\n * \n * This module follows SOLID principles:\n * - Single Responsibility: Each class and function has a specific purpose\n * - Open/Closed: Components can be extended without modification\n * - Liskov Substitution: Interfaces define contracts that implementations must follow\n * - Interface Segregation: Each interface exposes only what clients need\n * - Dependency Inversion: High-level modules depend on abstractions\n */\nimport OpenAI from 'openai';\nimport WebSocket from 'ws';\nimport { WebSocketState } from './websocket';\n\n// Configuration constants - making magic numbers explicit\nconst CONFIG = {\n  CLEANUP_INTERVAL_MS: 30000,    // How often to check for and remove inactive sessions\n  SESSION_MAX_AGE_MS: 60000,     // How long a session can be inactive before cleanup\n  MIN_AUDIO_SIZE_BYTES: 2000,    // Minimum audio chunk size to process\n  MAX_AUDIO_BUFFER_BYTES: 640000, // ~5 seconds at 128kbps\n  WHISPER_MODEL: 'whisper-1',    // OpenAI model to use for transcription\n  LOG_PREFIX: '[OpenAI Streaming]'// Prefix for all logs from this module\n};\n\n// Log API key status (masked for security)\nconsole.log(`OpenAI Streaming - API key status: ${process.env.OPENAI_API_KEY ? 'Present' : 'Missing'}`);\n\n/**\n * OpenAI client initialization - follows the factory pattern\n * Using a class instead of a global variable for better encapsulation\n */\nclass OpenAIClientFactory {\n  private static instance: OpenAI;\n  \n  /**\n   * Get the OpenAI client instance (singleton pattern)\n   */\n  public static getInstance(): OpenAI {\n    if (!this.instance) {\n      try {\n        this.instance = new OpenAI({ \n          apiKey: process.env.OPENAI_API_KEY || 'sk-placeholder-for-initialization-only'\n        });\n        console.log('OpenAI Streaming - client initialized successfully');\n      } catch (error) {\n        console.error('OpenAI Streaming - Error initializing client:', error);\n        // Create a placeholder client that will throw proper errors when methods are called\n        this.instance = new OpenAI({ apiKey: 'sk-placeholder-for-initialization-only' });\n      }\n    }\n    return this.instance;\n  }\n}\n\n// Define interfaces for our domain model\ninterface TranscriptionResult {\n  text: string;\n  isFinal: boolean;\n  languageCode: string;\n  confidence?: number;\n}\n\ninterface AudioStreamingSessionState {\n  sessionId: string;\n  language: string;\n  isProcessing: boolean;\n  audioBuffer: Buffer[];\n  lastChunkTime: number;\n  transcriptionText: string;\n  transcriptionInProgress: boolean;\n}\n\n/**\n * Session Manager - responsible for maintaining session state\n * Follows the repository pattern for data access\n */\nclass SessionManager {\n  private sessions = new Map<string, AudioStreamingSessionState>();\n  \n  /**\n   * Create a new streaming session\n   */\n  createSession(sessionId: string, language: string, initialBuffer: Buffer): AudioStreamingSessionState {\n    const session: AudioStreamingSessionState = {\n      sessionId,\n      language,\n      isProcessing: false,\n      audioBuffer: [initialBuffer],\n      lastChunkTime: Date.now(),\n      transcriptionText: '',\n      transcriptionInProgress: false\n    };\n    \n    this.sessions.set(sessionId, session);\n    console.log(`${CONFIG.LOG_PREFIX} Created new session: ${sessionId}, language: ${language}`);\n    return session;\n  }\n  \n  /**\n   * Get an existing session\n   */\n  getSession(sessionId: string): AudioStreamingSessionState | undefined {\n    return this.sessions.get(sessionId);\n  }\n  \n  /**\n   * Add audio data to an existing session\n   */\n  addAudioToSession(sessionId: string, audioBuffer: Buffer): void {\n    const session = this.getSession(sessionId);\n    if (session) {\n      session.audioBuffer.push(audioBuffer);\n      session.lastChunkTime = Date.now();\n    }\n  }\n  \n  /**\n   * Delete a session\n   */\n  deleteSession(sessionId: string): boolean {\n    const result = this.sessions.delete(sessionId);\n    if (result) {\n      console.log(`${CONFIG.LOG_PREFIX} Deleted session: ${sessionId}`);\n    }\n    return result;\n  }\n  \n  /**\n   * Clean up inactive sessions\n   */\n  cleanupInactiveSessions(maxAgeMs: number = CONFIG.SESSION_MAX_AGE_MS): void {\n    const now = Date.now();\n    \n    // Convert entries to array first (avoids downlevelIteration issues)\n    for (const [sessionId, session] of Array.from(this.sessions.entries())) {\n      const sessionAge = now - session.lastChunkTime;\n      \n      if (sessionAge > maxAgeMs) {\n        console.log(`${CONFIG.LOG_PREFIX} Cleaning up inactive session: ${sessionId}, age: ${sessionAge}ms`);\n        this.sessions.delete(sessionId);\n      }\n    }\n  }\n  \n  /**\n   * Get all sessions\n   */\n  getAllSessions(): Map<string, AudioStreamingSessionState> {\n    return this.sessions;\n  }\n}\n\n// Singleton instance of the session manager\nconst sessionManager = new SessionManager();\n\n/**\n * WebSocket communication utilities\n * Encapsulates message formatting and sending\n */\nclass WebSocketCommunicator {\n  /**\n   * Send a transcription result over WebSocket\n   */\n  static sendTranscriptionResult(\n    ws: WebSocket, \n    result: TranscriptionResult\n  ): void {\n    this.sendMessage(ws, {\n      type: 'transcription',\n      ...result\n    });\n  }\n  \n  /**\n   * Send an error message over WebSocket\n   */\n  static sendErrorMessage(\n    ws: WebSocket, \n    message: string, \n    errorType: string = 'server_error'\n  ): void {\n    this.sendMessage(ws, {\n      type: 'error',\n      message,\n      errorType\n    });\n  }\n  \n  /**\n   * Send a generic message over WebSocket\n   * Private helper method used by other public methods\n   */\n  private static sendMessage(ws: WebSocket, message: any): void {\n    // Only send if the connection is open\n    if (ws.readyState === WebSocketState.OPEN) {\n      ws.send(JSON.stringify(message));\n    }\n  }\n}\n\n/**\n * Audio Processing Service - handles transcription using OpenAI\n */\nclass AudioProcessingService {\n  private openai: OpenAI;\n  \n  constructor() {\n    // Get the OpenAI client from our factory\n    this.openai = OpenAIClientFactory.getInstance();\n  }\n  \n  /**\n   * Process audio buffer and get transcription\n   */\n  async transcribeAudio(audioBuffer: Buffer, language: string): Promise<string> {\n    try {\n      // Create file from buffer\n      const webmBlob = new Blob([audioBuffer], { type: 'audio/webm' });\n      const file = new File([webmBlob], 'audio.webm', { type: 'audio/webm' });\n      \n      // Get base language code without region (e.g., 'en' from 'en-US')\n      const baseLanguage = language.split('-')[0];\n      \n      // Use OpenAI to transcribe\n      const transcription = await this.openai.audio.transcriptions.create({\n        file: file,\n        model: CONFIG.WHISPER_MODEL,\n        language: baseLanguage,\n        response_format: 'json',\n      });\n      \n      return transcription.text || '';\n    } catch (error) {\n      console.error(`${CONFIG.LOG_PREFIX} Transcription error:`, error);\n      throw new Error(`Transcription failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n}\n\n// Create a single instance of the audio processor\nconst audioProcessor = new AudioProcessingService();\n\n/**\n * Process streaming audio data from WebSocket\n * \n * @param ws WebSocket connection\n * @param sessionId Unique session ID\n * @param audioBase64 Base64-encoded audio data\n * @param isFirstChunk Whether this is the first chunk in a new stream\n * @param language Language code for transcription (e.g., 'en-US')\n */\nexport async function processStreamingAudio(\n  ws: WebSocket,\n  sessionId: string,\n  audioBase64: string,\n  isFirstChunk: boolean,\n  language: string\n): Promise<void> {\n  try {\n    // Convert base64 to buffer\n    const audioBuffer = Buffer.from(audioBase64, 'base64');\n    \n    // Initialize session if it's the first chunk or doesn't exist\n    if (isFirstChunk || !sessionManager.getSession(sessionId)) {\n      sessionManager.createSession(sessionId, language, audioBuffer);\n    } else {\n      // Add to existing session\n      sessionManager.addAudioToSession(sessionId, audioBuffer);\n    }\n    \n    // Process if not already processing\n    const session = sessionManager.getSession(sessionId);\n    if (session && !session.transcriptionInProgress) {\n      // Start processing in the background\n      processAudioChunks(ws, sessionId).catch(error => {\n        console.error(`${CONFIG.LOG_PREFIX} Error processing audio chunks:`, error);\n        WebSocketCommunicator.sendErrorMessage(ws, 'Error processing audio stream', 'server_error');\n      });\n    }\n  } catch (error) {\n    console.error(`${CONFIG.LOG_PREFIX} Error processing streaming audio:`, error);\n    WebSocketCommunicator.sendErrorMessage(ws, 'Failed to process audio data', 'server_error');\n  }\n}\n\n/**\n * Process accumulated audio chunks for a session\n * \n * @param ws WebSocket connection\n * @param sessionId Session ID\n */\nasync function processAudioChunks(ws: WebSocket, sessionId: string): Promise<void> {\n  const session = sessionManager.getSession(sessionId);\n  if (!session || session.audioBuffer.length === 0) return;\n  \n  // Mark as processing to prevent concurrent processing\n  session.transcriptionInProgress = true;\n  \n  try {\n    // Create a single buffer from all chunks\n    const combinedBuffer = Buffer.concat(session.audioBuffer);\n    \n    // Manage buffer size to maintain context but reduce processing load\n    if (combinedBuffer.length > CONFIG.MAX_AUDIO_BUFFER_BYTES) {\n      // Keep only the most recent audio\n      session.audioBuffer = [combinedBuffer.slice(-CONFIG.MAX_AUDIO_BUFFER_BYTES)];\n    } else {\n      // Clear processed audio chunks\n      session.audioBuffer = [];\n    }\n    \n    // Skip processing if buffer is too small\n    if (combinedBuffer.length < CONFIG.MIN_AUDIO_SIZE_BYTES) {\n      session.transcriptionInProgress = false;\n      return;\n    }\n    \n    // Transcribe using our audio processing service\n    const transcriptionText = await audioProcessor.transcribeAudio(\n      combinedBuffer, \n      session.language\n    );\n    \n    // Send result if we got meaningful text\n    if (transcriptionText && transcriptionText.trim() !== '') {\n      // Store the latest transcription for finalization\n      session.transcriptionText = transcriptionText;\n      \n      // Send back transcription result\n      WebSocketCommunicator.sendTranscriptionResult(ws, {\n        text: transcriptionText,\n        isFinal: false,\n        languageCode: session.language\n      });\n    }\n  } catch (error) {\n    console.error(`${CONFIG.LOG_PREFIX} Error transcribing audio:`, error);\n    WebSocketCommunicator.sendErrorMessage(ws, 'Failed to transcribe audio', 'server_error');\n  } finally {\n    // Mark as done processing\n    session.transcriptionInProgress = false;\n  }\n}\n\n/**\n * Finalize a streaming session\n * \n * @param ws WebSocket connection\n * @param sessionId Session ID\n */\nexport async function finalizeStreamingSession(ws: WebSocket, sessionId: string): Promise<void> {\n  try {\n    const session = sessionManager.getSession(sessionId);\n    if (!session) return;\n    \n    // Process any remaining audio\n    if (session.audioBuffer.length > 0) {\n      await processAudioChunks(ws, sessionId);\n    }\n    \n    // Send final transcription\n    WebSocketCommunicator.sendTranscriptionResult(ws, {\n      text: session.transcriptionText,\n      isFinal: true,\n      languageCode: session.language\n    });\n    \n    // Clean up the session\n    sessionManager.deleteSession(sessionId);\n    console.log(`${CONFIG.LOG_PREFIX} Finalized and closed session: ${sessionId}`);\n  } catch (error) {\n    console.error(`${CONFIG.LOG_PREFIX} Error finalizing session:`, error);\n  }\n}\n\n/**\n * Clean up inactive streaming sessions\n * This should be called periodically to prevent memory leaks\n */\nexport function cleanupInactiveStreamingSessions(maxAgeMs: number = CONFIG.SESSION_MAX_AGE_MS): void {\n  sessionManager.cleanupInactiveSessions(maxAgeMs);\n}\n\n// Set up a periodic cleanup task\nsetInterval(() => {\n  cleanupInactiveStreamingSessions();\n}, CONFIG.CLEANUP_INTERVAL_MS);"]}