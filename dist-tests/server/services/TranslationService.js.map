{"version":3,"file":"TranslationService.js","sourceRoot":"","sources":["../../../server/services/TranslationService.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Translation Service\n * \n * This service is responsible for transcribing and translating speech.\n * It applies the following principles:\n * - Single Responsibility Principle (SRP): Each class has one job\n * - Open/Closed Principle: Open for extension, closed for modification\n * - Interface Segregation: Clients depend only on what they need\n * - Dependency Inversion: Depend on abstractions\n * - Pragmatic Principle #11: DRY - Don't Repeat Yourself\n * - Pragmatic Principle #13: Eliminate Effects Between Unrelated Things\n * - Pragmatic Principle #17: Program Close to the Problem Domain\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nimport OpenAI from 'openai';\nimport { storage } from '../storage';\nimport { textToSpeechService, ttsFactory } from './TextToSpeechService';\n// Add these at the top of the file (after existing imports)\nimport { promisify } from 'util';\nimport dotenv from 'dotenv';\nimport { fileURLToPath } from 'url';\n\n// Add this code near the top of the file\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Load environment variables\ndotenv.config({ path: path.resolve(__dirname, '../../.env') });\n\n\n// Promisify file system operations\nconst writeFile = promisify(fs.writeFile);\nconst unlink = promisify(fs.unlink);\nconst stat = promisify(fs.stat);\n\n// Constants for configuration\nconst TEMP_DIR = '/home/runner/workspace';\nconst DEFAULT_WHISPER_MODEL = 'whisper-1';\nconst DEFAULT_CHAT_MODEL = 'gpt-4o'; // the newest OpenAI model is \"gpt-4o\" which was released May 13, 2024\n\n// Language maps for better domain representation\nconst LANGUAGE_MAP: Record<string, string> = {\n  'en-US': 'English',\n  'fr-FR': 'French',\n  'es-ES': 'Spanish',\n  'de-DE': 'German',\n  'it-IT': 'Italian',\n  'ja-JP': 'Japanese',\n  'ko-KR': 'Korean',\n  'pt-BR': 'Portuguese',\n  'ru-RU': 'Russian',\n  'zh-CN': 'Chinese (Simplified)',\n  'ar-SA': 'Arabic',\n  'hi-IN': 'Hindi',\n  'tr-TR': 'Turkish',\n  'nl-NL': 'Dutch',\n  'pl-PL': 'Polish',\n  'sv-SE': 'Swedish',\n  'da-DK': 'Danish',\n  'fi-FI': 'Finnish',\n  'no-NO': 'Norwegian',\n  'cs-CZ': 'Czech',\n  'hu-HU': 'Hungarian',\n  'el-GR': 'Greek',\n  'he-IL': 'Hebrew',\n  'th-TH': 'Thai',\n  'vi-VN': 'Vietnamese',\n  'id-ID': 'Indonesian',\n  'ms-MY': 'Malay',\n  'ro-RO': 'Romanian',\n  'uk-UA': 'Ukrainian',\n  'bg-BG': 'Bulgarian',\n  'hr-HR': 'Croatian',\n  'sr-RS': 'Serbian',\n  'sk-SK': 'Slovak',\n  'sl-SI': 'Slovenian',\n  'et-EE': 'Estonian',\n  'lv-LV': 'Latvian',\n  'lt-LT': 'Lithuanian'\n};\n\n// Suspicious phrases that indicate prompt leakage\nconst SUSPICIOUS_PHRASES = [\n  \"If there is no speech or only background noise, return an empty string\",\n  \"This is classroom speech from a teacher\",\n  \"Transcribe any audible speech accurately\",\n  \"return an empty string\"\n];\n\n/**\n * Result interface for translation operations\n */\nexport interface TranslationResult {\n  originalText: string;\n  translatedText: string;\n  audioBuffer: Buffer;\n}\n\n/**\n * Interface for a transcription service\n * Following Interface Segregation Principle\n */\nexport interface ITranscriptionService {\n  transcribe(audioBuffer: Buffer, sourceLanguage: string): Promise<string>;\n}\n\n/**\n * Interface for a translation service\n * Following Interface Segregation Principle\n */\nexport interface ITranslationService {\n  translate(text: string, sourceLanguage: string, targetLanguage: string): Promise<string>;\n}\n\n/**\n * Audio file handler for temporary file operations\n * Following Single Responsibility Principle\n */\nclass AudioFileHandler {\n  private readonly tempDir: string;\n  \n  constructor(tempDir: string = TEMP_DIR) {\n    this.tempDir = tempDir;\n  }\n  \n  /**\n   * Create a temporary file from an audio buffer\n   */\n  async createTempFile(audioBuffer: Buffer): Promise<string> {\n    const filePath = path.join(this.tempDir, `temp-audio-${Date.now()}.wav`);\n    \n    try {\n      await writeFile(filePath, audioBuffer);\n      console.log(`Saved audio buffer to temporary file: ${filePath}`);\n      \n      const fileStats = await stat(filePath);\n      console.log(`Audio file size: ${fileStats.size} bytes, created: ${fileStats.mtime}`);\n      console.log(`Audio duration estimate: ~${Math.round(fileStats.size / 16000 / 2)} seconds`);\n      \n      return filePath;\n    } catch (error) {\n      console.error('Error creating temporary audio file:', error);\n      throw new Error('Failed to create temporary audio file');\n    }\n  }\n  \n  /**\n   * Delete a temporary file\n   */\n  async deleteTempFile(filePath: string): Promise<void> {\n    try {\n      await unlink(filePath);\n      console.log(`Deleted temporary file: ${filePath}`);\n    } catch (error) {\n      console.error('Error cleaning up temporary file:', error);\n      // Don't throw here - cleaning up is a best effort\n    }\n  }\n}\n\n/**\n * OpenAI Whisper Transcription Service\n * Handles audio transcription using OpenAI's Whisper API\n */\nexport class OpenAITranscriptionService implements ITranscriptionService {\n  private readonly openai: OpenAI;\n  private readonly audioHandler: AudioFileHandler;\n  \n  constructor(\n    openai: OpenAI,\n    audioHandler: AudioFileHandler = new AudioFileHandler()\n  ) {\n    this.openai = openai;\n    this.audioHandler = audioHandler;\n  }\n  \n  /**\n   * Transcribe audio using OpenAI Whisper API\n   */\n  async transcribe(audioBuffer: Buffer, sourceLanguage: string): Promise<string> {\n    // Skip transcription for empty or tiny audio buffers\n    if (!audioBuffer || audioBuffer.length < 1000) {\n      console.log(`Audio buffer too small for transcription: ${audioBuffer?.length} bytes`);\n      return '';\n    }\n    \n    console.log(`Transcribing audio buffer of size ${audioBuffer.length}...`);\n    console.log(`Audio buffer header (hex): ${audioBuffer.slice(0, 32).toString('hex')}`);\n    console.log(`Audio buffer has valid WAV header: ${audioBuffer.slice(0, 4).toString() === 'RIFF'}`);\n    \n    let tempFilePath = '';\n    \n    try {\n      // Create temporary file from audio buffer\n      tempFilePath = await this.audioHandler.createTempFile(audioBuffer);\n      \n      // Create stream from file\n      const audioReadStream = fs.createReadStream(tempFilePath);\n      console.log('Sending read stream to OpenAI API');\n      \n      // Use minimal parameters to avoid hallucination issues\n      console.log('Using minimal parameters with no prompt to avoid preconceptions');\n      \n      // Extract the primary language code (e.g., 'en' from 'en-US')\n      const primaryLanguage = sourceLanguage.split('-')[0];\n      \n      // Transcribe with OpenAI Whisper API\n      const transcriptionResponse = await this.openai.audio.transcriptions.create({\n        file: audioReadStream,\n        model: DEFAULT_WHISPER_MODEL,\n        language: primaryLanguage,\n        response_format: 'json'\n      });\n      \n      // Log the full response for debugging\n      console.log(`Full transcription response: ${JSON.stringify(transcriptionResponse)}`);\n      \n      // Use the detected text or empty string if not found\n      if (transcriptionResponse.text) {\n        const originalText = transcriptionResponse.text;\n        console.log(`Transcription successful: { text: '${originalText}' }`);\n        console.log(`📢 DIAGNOSTIC - EXACT TRANSCRIPTION FROM OPENAI: \"${originalText}\"`);\n        \n        // Check for potential prompt leakage\n        const isPotentialPromptLeak = SUSPICIOUS_PHRASES.some(phrase => \n          originalText.includes(phrase)\n        );\n        \n        if (isPotentialPromptLeak) {\n          console.log('⚠️ DETECTED PROMPT LEAKAGE: The transcription appears to contain prompt instructions');\n          console.log('Treating this as an empty transcription and triggering fallback mechanism');\n          return '';\n        }\n        \n        return originalText;\n      } else {\n        console.log('Transcription returned no text - Whisper API failed to detect speech');\n        return '';\n      }\n    } catch (error: unknown) {\n      console.error('Error during transcription:', error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Transcription failed: ${errorMessage}`);\n    } finally {\n      // Clean up the temporary file\n      if (tempFilePath) {\n        await this.audioHandler.deleteTempFile(tempFilePath);\n      }\n    }\n  }\n}\n\n/**\n * Error response interface for standardized error handling\n */\ninterface TranslationErrorResponse {\n  error: string;\n  originalText: string;\n  retryCount: number;\n  statusCode?: number;\n  shouldRetry: boolean;\n}\n\n/**\n * OpenAI Translation Service\n * Handles text translation using OpenAI's GPT API\n * Implements proper error handling with retry logic\n */\nexport class OpenAITranslationService implements ITranslationService {\n  private readonly openai: OpenAI;\n  private readonly maxRetries: number = 3;\n  \n  constructor(openai: OpenAI) {\n    this.openai = openai;\n  }\n  \n  /**\n   * Get the full language name from a language code\n   */\n  private getLanguageName(languageCode: string): string {\n    return LANGUAGE_MAP[languageCode] || languageCode.split('-')[0];\n  }\n  \n  /**\n   * Handle translation errors in a standardized way\n   * Extracts useful information from various error types\n   */\n  private handleTranslationError(error: unknown, originalText: string, retryCount: number): TranslationErrorResponse {\n    let errorMessage = 'Unknown error occurred';\n    let statusCode: number | undefined = undefined;\n    let shouldRetry = retryCount < this.maxRetries;\n    \n    // Process different types of errors\n    if (error instanceof Error) {\n      errorMessage = error.message;\n      \n      // Check for specific OpenAI API error patterns\n      if ('status' in error && typeof (error as any).status === 'number') {\n        statusCode = (error as any).status;\n        \n        // Only retry on specific error codes (429 rate limit, 500 server error, etc.)\n        const code = statusCode || 0; // Use 0 if undefined\n        shouldRetry = retryCount < this.maxRetries && \n          (code === 429 || code >= 500 || code === 0);\n      }\n    }\n    \n    console.error(`Translation error [attempt ${retryCount + 1}/${this.maxRetries + 1}]:`, errorMessage);\n    \n    return {\n      error: errorMessage,\n      originalText,\n      retryCount,\n      statusCode,\n      shouldRetry\n    };\n  }\n  \n  /**\n   * Create translation request with exponential backoff retry\n   */\n  private async executeWithRetry(\n    text: string,\n    sourceLangName: string,\n    targetLangName: string,\n    retryCount: number = 0\n  ): Promise<string> {\n    try {\n      const prompt = `\n        Translate this text from ${sourceLangName} to ${targetLangName}. \n        Maintain the same tone and style. Return only the translation without explanations or notes.\n        \n        Original text: \"${text}\"\n        \n        Translation:\n      `;\n      \n      const translation = await this.openai.chat.completions.create({\n        model: DEFAULT_CHAT_MODEL,\n        messages: [\n          { role: 'system', content: 'You are a professional translator with expertise in multiple languages.' },\n          { role: 'user', content: prompt }\n        ],\n        temperature: 0.1,\n        max_tokens: 500\n      });\n      \n      const translatedText = translation.choices[0].message.content?.trim() || text;\n      return translatedText;\n    } catch (error) {\n      const errorResponse = this.handleTranslationError(error, text, retryCount);\n      \n      // Implement exponential backoff retry\n      if (errorResponse.shouldRetry) {\n        const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff\n        console.log(`Retrying translation in ${delay}ms...`);\n        \n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.executeWithRetry(text, sourceLangName, targetLangName, retryCount + 1);\n      }\n      \n      // If we've exhausted retries or shouldn't retry, throw a standardized error\n      throw new Error(`Translation failed after ${retryCount + 1} attempts: ${errorResponse.error}`);\n    }\n  }\n  \n  /**\n   * Translate text from one language to another\n   * Implementation now has reduced complexity by separating concerns\n   */\n  async translate(\n    text: string, \n    sourceLanguage: string, \n    targetLanguage: string\n  ): Promise<string> {\n    // Skip translation for empty text\n    if (!text) {\n      return '';\n    }\n    \n    // If target language is the same as source language, no translation needed\n    if (targetLanguage === sourceLanguage) {\n      console.log(`No translation needed - source and target language are the same (${targetLanguage})`);\n      return text;\n    }\n    \n    try {\n      const sourceLangName = this.getLanguageName(sourceLanguage);\n      const targetLangName = this.getLanguageName(targetLanguage);\n      \n      const translatedText = await this.executeWithRetry(text, sourceLangName, targetLangName);\n      \n      console.log(`Successfully processed translation to ${targetLanguage}`);\n      console.log(`Translation complete: \"${text}\" -> \"${translatedText}\"`);\n      \n      return translatedText;\n    } catch (error: unknown) {\n      console.error(`Error translating to ${targetLanguage}:`, error);\n      \n      // For production, we'd log this error to a monitoring system\n      if (error instanceof Error) {\n        console.error(`Translation error details: ${error.message}`);\n      }\n      \n      // Return empty string to indicate failure, better than returning misleading text\n      return '';\n    }\n  }\n}\n\n/**\n * Helper for creating development mode audio buffers\n * Extracted to reduce complexity in main service class\n */\nclass DevelopmentModeHelper {\n  /**\n   * Create a simple WAV buffer with silence\n   * Used for development mode when no real audio processing is available\n   */\n  static createSilentAudioBuffer(): Buffer {\n    // Create a minimal PCM WAV header\n    const wavHeader = Buffer.from([\n      0x52, 0x49, 0x46, 0x46, // \"RIFF\"\n      0x24, 0x00, 0x00, 0x00, // ChunkSize (36 bytes + data size)\n      0x57, 0x41, 0x56, 0x45, // \"WAVE\"\n      0x66, 0x6d, 0x74, 0x20, // \"fmt \"\n      0x10, 0x00, 0x00, 0x00, // Subchunk1Size (16 bytes)\n      0x01, 0x00,             // AudioFormat (1 = PCM)\n      0x01, 0x00,             // NumChannels (1 = mono)\n      0x44, 0xac, 0x00, 0x00, // SampleRate (44100 Hz)\n      0x88, 0x58, 0x01, 0x00, // ByteRate (SampleRate * NumChannels * BitsPerSample/8)\n      0x02, 0x00,             // BlockAlign (NumChannels * BitsPerSample/8)\n      0x10, 0x00,             // BitsPerSample (16 bits)\n      0x64, 0x61, 0x74, 0x61, // \"data\"\n      0x00, 0x00, 0x00, 0x00  // Subchunk2Size (data size)\n    ]);\n    \n    // Add some silence (1 second)\n    const sampleCount = 44100;\n    const dataSize = sampleCount * 2; // 16-bit samples\n    const silenceData = Buffer.alloc(dataSize);\n    \n    // Update the data chunk size in the header\n    wavHeader.writeUInt32LE(dataSize, 40);\n    // Update the overall file size in the header\n    wavHeader.writeUInt32LE(36 + dataSize, 4);\n    \n    // Combine header and data\n    return Buffer.concat([wavHeader, silenceData]);\n  }\n  \n  /**\n   * Get a synthetic translation based on target language\n   */\n  static getLanguageSpecificTranslation(text: string, targetLanguage: string): string {\n    // Simple mapping for common languages in development mode\n    const devTranslations: Record<string, string> = {\n      es: 'Esto es una traducción en modo de desarrollo.',\n      fr: 'Ceci est une traduction en mode développement.',\n      de: 'Dies ist eine Übersetzung im Entwicklungsmodus.',\n    };\n    \n    // Extract language code without region (e.g., 'es' from 'es-ES')\n    const langPrefix = targetLanguage.split('-')[0].toLowerCase();\n    \n    // Return mapped translation or original text if no mapping exists\n    return devTranslations[langPrefix] || text;\n  }\n}\n\n/**\n * Composite Speech Translation Service\n * Orchestrates the entire translation workflow\n * Following the Facade pattern and Strategy pattern to simplify the API\n */\nexport class SpeechTranslationService {\n  private readonly transcriptionService: ITranscriptionService;\n  private readonly translationService: ITranslationService;\n  private readonly apiKeyAvailable: boolean;\n  \n  constructor(\n    transcriptionService: ITranscriptionService,\n    translationService: ITranslationService,\n    apiKeyAvailable: boolean\n  ) {\n    this.transcriptionService = transcriptionService;\n    this.translationService = translationService;\n    this.apiKeyAvailable = apiKeyAvailable;\n  }\n  \n  /**\n   * Create development mode synthetic translation for testing without API key\n   */\n  private createDevelopmentModeTranslation(\n    sourceLanguage: string,\n    targetLanguage: string,\n    preTranscribedText?: string\n  ): TranslationResult {\n    console.log('DEV MODE: Using synthetic translation data due to missing API key');\n    \n    // Get the transcription from WebSpeech API if available\n    const originalText = preTranscribedText || 'This is a development mode transcription.';\n    \n    // Get language-specific translation\n    const translatedText = DevelopmentModeHelper.getLanguageSpecificTranslation(\n      originalText, \n      targetLanguage\n    );\n    \n    // Create a simple audio buffer with silence\n    const audioBuffer = DevelopmentModeHelper.createSilentAudioBuffer();\n    \n    console.log(`DEV MODE: Returning synthetic translation: \"${translatedText}\"`);\n    \n    return {\n      originalText,\n      translatedText,\n      audioBuffer\n    };\n  }\n  \n  /**\n   * Get text either from pre-transcribed input or by transcribing audio\n   * Extracted to reduce complexity\n   */\n  private async getOriginalText(\n    audioBuffer: Buffer,\n    sourceLanguage: string,\n    preTranscribedText?: string\n  ): Promise<string> {\n    // If text is already provided, skip transcription step\n    if (preTranscribedText) {\n      console.log(`Using pre-transcribed text instead of audio: \"${preTranscribedText}\"`);\n      return preTranscribedText;\n    }\n    \n    // Transcribe the audio\n    try {\n      return await this.transcriptionService.transcribe(audioBuffer, sourceLanguage);\n    } catch (error: unknown) {\n      console.error('Transcription service failed:', error);\n      return '';\n    }\n  }\n  \n  /**\n   * Translate text to target language\n   * Extracted to reduce complexity\n   */\n  private async translateText(\n    text: string,\n    sourceLanguage: string,\n    targetLanguage: string\n  ): Promise<string> {\n    try {\n      return await this.translationService.translate(\n        text,\n        sourceLanguage,\n        targetLanguage\n      );\n    } catch (error) {\n      console.error('Translation service failed:', error);\n      return '';\n    }\n  }\n  \n  /**\n   * Transcribe and translate speech\n   * Main public method that orchestrates the workflow\n   * Now includes emotional tone preservation in synthesized speech\n   */\n  async translateSpeech(\n    audioBuffer: Buffer,\n    sourceLanguage: string,\n    targetLanguage: string,\n    preTranscribedText?: string,\n    options?: { ttsServiceType?: string }\n  ): Promise<TranslationResult> {\n    console.log(`Processing speech translation from ${sourceLanguage} to ${targetLanguage}`);\n    \n    // DEVELOPMENT MODE: Check if API key is missing\n    if (!this.apiKeyAvailable) {\n      return this.createDevelopmentModeTranslation(sourceLanguage, targetLanguage, preTranscribedText);\n    }\n    \n    // Get original text (either from transcription or pre-provided)\n    const originalText = await this.getOriginalText(\n      audioBuffer,\n      sourceLanguage,\n      preTranscribedText\n    );\n    \n    // Skip empty transcriptions\n    if (!originalText) {\n      return { \n        originalText: '', \n        translatedText: '', \n        audioBuffer \n      };\n    }\n    \n    // Translate the text\n    const translatedText = await this.translateText(\n      originalText,\n      sourceLanguage,\n      targetLanguage\n    );\n    \n    // Generate speech audio with emotional tone preservation\n    let translatedAudioBuffer = audioBuffer; // Default to original audio\n    \n    try {\n      // Use TTS service type from options if provided, or fall back to environment or default 'browser'\n      const ttsServiceType = (options && options.ttsServiceType) || process.env.TTS_SERVICE_TYPE || 'browser';\n      \n      // Log the TTS service being used\n      console.log(`Using TTS service '${ttsServiceType}' for language '${targetLanguage}'`);\n      \n      // Get the appropriate TTS service from the factory\n      const ttsService = ttsFactory.getService(ttsServiceType);\n      \n      // Use the selected TTS service to generate audio with emotion preservation\n      translatedAudioBuffer = await ttsService.synthesizeSpeech({\n        text: translatedText || originalText,\n        languageCode: targetLanguage,\n        preserveEmotions: true // Enable emotional tone preservation\n      });\n      \n      console.log(`Generated translated audio using ${ttsServiceType} service: ${translatedAudioBuffer.length} bytes`);\n    } catch (error) {\n      console.error('Error generating audio for translation:', error);\n      // On error, keep the original audio buffer\n    }\n    \n    return { \n      originalText, \n      translatedText: translatedText || originalText, // Fallback to original text if translation failed\n      audioBuffer: translatedAudioBuffer\n    };\n  }\n}\n\n// Replace the problematic OpenAI initialization section (around line 637) with this:\n// Initialize OpenAI client with API key from environment\nlet openai: OpenAI;\n\ntry {\n  // Check for OpenAI API key\n  if (!process.env.OPENAI_API_KEY) {\n    console.warn('OpenAI API key status: Missing');\n    console.warn('OPENAI_API_KEY is missing or empty. This might cause API failures.');\n  } else {\n    console.log('OpenAI API key status: Present');\n  }\n  \n  // Initialize OpenAI client\n  openai = new OpenAI({ \n    apiKey: process.env.OPENAI_API_KEY || 'sk-placeholder-for-initialization-only' \n  });\n  console.log('OpenAI client initialized successfully');\n} catch (error) {\n  console.error('Error initializing OpenAI client:', error);\n  // Create a placeholder client that will throw proper errors when methods are called\n  openai = new OpenAI({ apiKey: 'sk-placeholder-for-initialization-only' });\n}\n\n// Create service instances\nconst audioHandler = new AudioFileHandler();\nconst transcriptionService = new OpenAITranscriptionService(openai, audioHandler);\nconst translationService = new OpenAITranslationService(openai);\n\n// Create and export the main service facade\nexport const speechTranslationService = new SpeechTranslationService(\n  transcriptionService,\n  translationService,\n  Boolean(process.env.OPENAI_API_KEY)\n);\n\n// Export the legacy function for backward compatibility\nexport async function translateSpeech(\n  audioBuffer: Buffer, \n  sourceLanguage: string, \n  targetLanguage: string,\n  preTranscribedText?: string,\n  ttsServiceType?: string | { ttsServiceType?: string }\n): Promise<TranslationResult> {\n  // Handle both string and object format\n  let ttsServiceOptions: { ttsServiceType?: string };\n  \n  if (typeof ttsServiceType === 'string') {\n    ttsServiceOptions = { ttsServiceType };\n    console.log(`Using TTS service '${ttsServiceType}' (string format)`);\n  } else {\n    ttsServiceOptions = ttsServiceType || {};\n    console.log(`Using TTS service options:`, ttsServiceOptions);\n  }\n  \n  return speechTranslationService.translateSpeech(\n    audioBuffer,\n    sourceLanguage,\n    targetLanguage,\n    preTranscribedText,\n    ttsServiceOptions\n  );\n}"]}