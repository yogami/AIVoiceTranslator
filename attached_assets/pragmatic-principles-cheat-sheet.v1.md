# Pragmatic Principles Cheat Sheet

```
The Pragmatic Principles
1.
Care Ab out Your Craft
‹
Why sp end your life developing software unless you care ab out
doing it well?
2.
Think! Ab out Your Work
‹
Turn o˙ the autopilot and take control. Constantly critique
and appraise your work.
3.
Provide Options, Don't Make Lame Excuses
‹
Instead of excuses, provide options. Don't say it can't b e
done; explain what can b e done.
4.
Don't Live with Broken Windows
‹
Fix bad designs, wrong decisions, and p o or co de when you s ee
them.
5.
Be a Catalyst fo r Change
‹
You can't force change on p eople. Instead, show them how the
future might b e and help them participate in creating it.
6.
Rememb er the Big Picture
‹
Don't get so engrossed in the details that you forget to check
what's happ ening around you.
7.
Make Quality a Requirements Issue
‹
Involve your users in determining the pro j ect's real quali ty
requirements.
8.
Invest Regularly in Your Knowledge Portfolio
‹
Make learning a habit.
9.
Critically Analyze What You Read and Hear
‹
Don't b e swayed by vendors, media hyp e, or dogma. Analyze
information in terms of you and your pro ject.
10.
It's Both What You Say and the Way You Say It
‹
There's no p oint in having great ideas if you don't
communicate them e˙ectively.
11.
DRY - Don't Rep eat Yourself
‹
Every piece of knowledge must have a single, unambi guous,
authoritative representation wi thi n a system.
12.
Make It Easy to Reuse
‹
If it's easy to reuse, p eople will. Create an environment that
supp orts reuse.
13.
Eliminate E˙ects Between Unrelated Things
‹
Design comp onents that are self-contained. indep endent, and
have a single, well-de˝ned purp ose.
14.
There Are No Final Decisions
‹
No decision is cast in stone. Instead, consider each as b eing
written in the sand at the b each, and plan for change.
15.
Use Tracer Bullets to Find the Target
‹
Tracer bullets let you home in on your target by trying thi ngs
and seeing how close they land.
16.
Prototyp e to Learn
‹
Prototyping is a learning exp erience. Its value lies not in the
co de you pro duce, but in the lessons you learn.
17.
Program Close to the Problem Domain
‹
Design and co de in your user's language.
18.
Estimate to Avoid Surprises
‹
Estimate b efore you start. You'll sp ot p otential problems up
front.
19.
Iterate the Schedule with the Co de
‹
Use exp erience you gain as you implement to re˝ne the
pro ject time scales.
20.
Keep Knowledge in Plain Text
‹
Plain text won't b ecome obsolete. It helps leverage your work
and simpli˝es debugging and testing.
21.
Use the Power of Command Shells
‹
Use the shell when graphical user interfaces don't cut it.
22.
Use a Single Editor Well
‹
The editor should b e an extension of your hand; make sure
your editor is con˝gurable, extensible, and programmable.
23.
Always Use Source Co de Control
‹
Source co de control is a time machine for your work - you can
go back.
24.
Fix the Problem, Not the Blame
‹
It do esn't reall y matter whether the bug is your fault or
someone else's - it is still your problem, and it still needs to b e
˝xed.
25.
Don't Panic When Debugging
‹
Take a deep breath and THINK! ab out what could b e caus ing
the bug.
26.
select Isn't Broken.
‹
It is rare to ˝nd a bug in the OS or the compiler, or even a
third-party pro duct or library. The bug is most likely in the
application.
27.
Don't Assume It - Prove It
‹
Prove your assumptions in the actual environment - with real
data and b oundary conditions.
28.
Learn a Text Manipulation Language.
‹
You sp end a large part of each day working with text. Why
not have the computer do some of it for you?
29.
Write Co de That Writes Co de
‹
Co de generators increase your pro ductivity and help avoid
duplication.
30.
You Can't Write Perfect Software
‹
Software can't b e p erfect. Protect your co de and users from
the inevitable errors.
31.
Design with Contracts
‹
Use contracts to do cument and verify that co de do es no more
and no less than it claims to do.
32.
Crash Early
‹
A dead program normally do es a lot less damage than a
crippled one.
33.
Use Assertions to Prevent the Imp ossible
‹
Assertions validate your assumptions. Use them to protect
your co de from an uncertain world.
34.
Use Exceptions for Exceptional Problems
‹
Exceptions can su˙er from all the readability and
maintainability problems of classic spaghetti co de. Reserve
exceptions for exceptional things.
35.
Finish What You Start
‹
Where p ossible, the routine or ob ject that allo cates a resource
should b e resp onsible for deallo cating it.
36.
Minimize Coupling Between M o dules
‹
Avoid coupling by writing shy co de and applying the Law of
Demeter.
37.
Con˝gure, Don't Integrate
‹
Implement technology choices for an application as
con˝guration opti ons, not through integration or engi neering.
38.
Put Abstractions in Co de, Details in Metadata
‹
Program for the general case, and put the sp eci ˝cs outside the
compiled co de base.
39.
Analyze Work˛ow to Improve Concurrency
‹
Exploit concurrency in your user's work˛ow.
40.
Design Using Services
‹
Design in terms of services - indep endent, concurrent ob jects
b ehind well-de˝ned, consistent interfaces.
41.
Always Design for C onc urrency
‹
Allow for concurrency, and you'll design cleaner interfaces
with fewer assumpti ons.
42.
Separate Views from Mo dels
‹
Gain ˛exibility at low cost by designi ng your application in
terms of mo dels and views.
43.
Use Blackb oards to Co ordinate Work˛ow
‹
Use blackb oards to co ordinate disparate facts and agents,
while maintaining indep endence and is ol ati on among
participants.
44.
Don't Program by Coincidence
‹
Rely only on reliable things. Beware of accidental complexity,
and don't confuse a happy coincidence with a purp oseful plan.
45.
Estimate the Order of Your Algorithms
‹
Get a feel for how long things are likely to take b efore you
write co de.
46.
Test Your Estimates
‹
Mathematical analysis of algorithms do esn't tell you
everything. Try timing your co de in its target environment.
47.
Refactor Early, Refactor O ften
‹
Just as you might weed and rearrange a garden, rewrite,
rework, and re-architect co de when it needs it. Fix the ro ot of
the problem.
48.
Design to Test
‹
Start thinking ab out testing b efore you write a line of co de.

49.
Test Your Software, or Your Users Will
‹
Test ruthlessl y. Don't make your users ˝nd bugs for you.
50.
Don't Use Wizard Co de You Don't Understand
‹
Wizards can generate reams of co de. Make sure you
understand all of it b efore you i ncorp orate it into your pro ject.
51.
Don't Gather Requirements - Dig for Them
‹
Requirements rarely lie on the surface. They're buried deep
b eneath layers of assumptions, misconceptions, and p oli tics.
52.
Workwith a User to Think Like a User
‹
It's the b est way to gain insight into how the system will
really b e used.
53.
Abstractions Live Longer than Deta ils
‹
Invest in the abstraction, not the implementation.
Abstractions can survive the barrage of changes from di˙erent
implementations and new technologi es .
54.
Use a Pro ject Glossary
‹
Create and maintain a single source of all the sp eci˝c terms
and vo cabulary for a pro ject.
55.
Don't Think Outside the Box - Find the Box
‹
When faced with an imp ossible problem, identify the real
constraints. Ask yourself: Do es it have to b e done this way?
Do es i t have to b e done at all?
56.
Start When You're Ready.
‹
You've b een building exp erience al l your life. Don't ignore
niggling doubts.
57.
Some Things Are Better Done than Describ ed
‹
Don't fall into the sp eci˝cation spiral - at some p oint you need
to start co ding.
58.
Don't Be a Slave to Formal Metho ds.
‹
Don't blindly adopt any techni que wi thout putting it into the
context of your development practices and capabilities.
59.
Costly To ols Don't Pro duce Better Designs
‹
Beware of vendor hyp e, industry dogma, and the aura of the
price tag. Judge to ols on their merits.
60.
Organize Teams Around Functionality
‹
Don't separate designers from co ders, testers from data
mo delers. Build teams the way you build co de.
61.
Don't Use Manual Pro cedures
‹
A shell script or batch ˝le will execute the same instructions,
in the same order, time after time.
62.
Test Early. Test Often. Test Automatically
‹
Tes ts that run w ith every build are much more e˙ective than
test plans that sit on a shelf.
63.
Co ding Ain't Done `Til All the Tests Run
‹
`Nu˙ said.
64.
Use Sab oteurs to Test Your Testing
‹
Intro duce bugs on purp ose in a separate copy of the source to
verify that testing wi ll catch them.
65.
Test State Coverage, Not Co de Coverage
‹
Identify and test signi˝cant program states. Just testing lines
of co de i sn' t enough.
66.
Find Bugs Once
‹
Once a human tester ˝nds a bug, it should b e the last time a
human tester ˝nds that bug. Automatic tests should check for
it from then on.
67.
English is Just a Programming Language
‹
Wri te do cuments as you would write co de: honor the DRY
principle, use metadata, MVC, automatic generation, and so
on.
68.
Build Do cumentation In, Don't Bolt It On
‹
Do cumentation created s eparately from co de is less likely to
b e correct and up to date.
69.
Gently Exceed Your Users' Exp ectations
‹
Come to understand your users' exp ectations, then deliver
just that little bit more.
70.
Sign Your Work
‹
Craftsmen of an earlier age were proud to sign their work.
You should b e, to o.
Languages To Learn
Tired of C, C++, and Java? Try CLOS, Dylan, Ei˙el, Ob jective
C, Prolog, Smalltalk, or TOM. Each of these languages has
di˙erent capabilities and a di˙erent ˛avor. Try a small pro ject
at home using one or more of them.
The WISDOM Acrostic
W
hat do you want them to learn?
What
i
s their interest in what you've got to say?
How
s
ophisticated are they?
How much
d
etail do they want?
Whom do you want to
o
wn the information?
How can you
m
otivate them to listen to you?
How to Maintain Orthogonality
‹
Design indep endent, well-de˝ned comp onents.
‹
Keep your co de decoupl ed.
‹
Avoid global data.
‹
Refactor similar functions.
Things to prototyp e
‹
Architecture
‹
New functionality in an existi ng s ystem
‹
Structure or contents of external data
‹
Third-party to ols or comp onents
‹
Performance issues
‹
User interf ace design
Architectural Questions
‹
Are resp onsibiliti es well de˝ned?
‹
Are the collab orations well de˝ned?
‹
Is coupling minimized?
‹
Can you identify p otential duplication?
‹
Are interface de˝nitions and constraints acceptable?
‹
Can mo dules access needed data - when needed?
Debugging Checklist
‹
Is the problem b eing rep orted a direct result of the underlyi ng
bug, or merely a symptom?
‹
Is the bug really i n the compiler? Is it in the OS? Or is it in your
co de?
‹
If you explained this problem in detail to a coworker, what
would you say?
‹
If the susp ect co de passes its unit tests, are the tests complete
enough? What happ ens if you run the unit tes t with this data?
‹
Do the conditions that caused thi s bug exist anywhere else in the
system?
Law of De meter for Functions
An ob ject's metho d should call only metho ds b elonging to:
‹
Itself
‹
Any parameters passed in
‹
Ob jects it creates
‹
Comp onent ob jects
How to Program Delib erately
‹
Stay aware of what you're doing.
‹
Don't co de blindfolded.
‹
Pro ceed from a plan.
‹
Rely only on reliable things.
‹
Do cument your assumptions.
‹
Test assumptions as well as co de.
‹
Prioritize your e˙ort.
‹
Don't b e a sl ave to his tory.
When to Refactor
You discover a violation of the DRY principle. You ˝nd things
that could b e more orthogonal. Your knowledge improves. The
requirements evolve. You need to improve p erformance.
Cutting the Gordian Knot
When solving
impossible
problems, ask yourself:
‹
Is there an easier way?
‹
Am I solving the right problem?
‹
Why i s this a problem?
‹
What makes i t hard?
‹
Do I have to do it this way?
‹
Do es i t have to b e done at all?
Asp ects of Testing
‹
Unit testing
‹
Integration testing
‹
Vali dation and veri˝cation
‹
Resource exhaustion, errors, and recovery
‹
Performance testing
‹
Usability testing
‹
Testi ng the tests thems el ves
```