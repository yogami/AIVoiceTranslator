antml.artifacts.create({
  command: "create",
  id: "enhanced-translation-service-test",
  type: "application/vnd.ant.code",
  language: "typescript",
  title: "EnhancedTranslationService.test.ts",
  content: `import { jest } from '@jest/globals';

// Mock modules before importing the service
jest.mock('url', () => ({
  fileURLToPath: jest.fn(() => '/mocked/file/path'),
}));

jest.mock('fs', () => {
  const mockFs = {
    createReadStream: jest.fn(() => ({
      // Basic mock of a readable stream
      on: jest.fn(),
      pipe: jest.fn(),
    })),
    writeFile: jest.fn((path, data, callback) => callback(null)),
    unlink: jest.fn((path, callback) => callback(null)),
    stat: jest.fn((path, callback) => callback(null, {
      size: 1024,
      mtime: new Date(),
    })),
    promises: {
      writeFile: jest.fn().mockResolvedValue(undefined),
      unlink: jest.fn().mockResolvedValue(undefined),
      stat: jest.fn().mockResolvedValue({
        size: 1024,
        mtime: new Date(),
      }),
    }
  };
  return mockFs;
});

// Mock OpenAI with more control for different test scenarios
const mockOpenAI = {
  audio: {
    transcriptions: {
      create: jest.fn().mockResolvedValue({
        text: 'This is a test transcription',
      }),
    },
  },
  chat: {
    completions: {
      create: jest.fn().mockResolvedValue({
        choices: [
          {
            message: {
              content: 'Esta es una traducción de prueba',
            },
          },
        ],
      }),
    },
  },
};

jest.mock('openai', () => {
  return {
    default: jest.fn().mockImplementation(() => mockOpenAI),
  };
});

// Mock dotenv
jest.mock('dotenv', () => ({
  config: jest.fn(),
}));

// Mock TTS service with more control
const mockTTSService = {
  synthesizeSpeech: jest.fn().mockResolvedValue(Buffer.from('mock-audio-data')),
};

const mockTTSFactory = {
  getService: jest.fn().mockReturnValue(mockTTSService),
};

jest.mock('../server/TextToSpeechService', () => ({
  textToSpeechService: mockTTSService,
  ttsFactory: mockTTSFactory,
}));

// Now import the service - the mocks will be used
import { 
  SpeechTranslationService, 
  OpenAITranscriptionService, 
  OpenAITranslationService,
  translateSpeech,
  AudioFileHandler
} from '../server/TranslationService';

// Test cases for the main service
describe('SpeechTranslationService', () => {
  let transcriptionService: any;
  let translationService: any;
  let speechTranslationService: any;
  
  beforeEach(() => {
    // Reset all mocks before each test
    jest.clearAllMocks();
    
    // Create mock services
    transcriptionService = {
      transcribe: jest.fn().mockResolvedValue('This is a test transcription'),
    };
    
    translationService = {
      translate: jest.fn().mockResolvedValue('Esta es una traducción de prueba'),
    };
    
    // Create the service to test
    speechTranslationService = new SpeechTranslationService(
      transcriptionService,
      translationService,
      true // apiKeyAvailable
    );
  });
  
  // Happy path test
  it('should translate speech correctly', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    
    // Act
    const result = await speechTranslationService.translateSpeech(
      audioBuffer,
      sourceLanguage,
      targetLanguage
    );
    
    // Assert
    expect(transcriptionService.transcribe).toHaveBeenCalledWith(audioBuffer, sourceLanguage);
    expect(translationService.translate).toHaveBeenCalledWith(
      'This is a test transcription',
      sourceLanguage,
      targetLanguage
    );
    expect(result).toEqual({
      originalText: 'This is a test transcription',
      translatedText: 'Esta es una traducción de prueba',
      audioBuffer: expect.any(Buffer)
    });
  });
  
  // Pre-transcribed text path
  it('should bypass transcription when preTranscribedText is provided', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    const preTranscribedText = 'Pre-transcribed text for testing';
    
    // Act
    const result = await speechTranslationService.translateSpeech(
      audioBuffer,
      sourceLanguage,
      targetLanguage,
      preTranscribedText
    );
    
    // Assert
    expect(transcriptionService.transcribe).not.toHaveBeenCalled();
    expect(translationService.translate).toHaveBeenCalledWith(
      preTranscribedText,
      sourceLanguage,
      targetLanguage
    );
    expect(result).toEqual({
      originalText: preTranscribedText,
      translatedText: 'Esta es una traducción de prueba',
      audioBuffer: expect.any(Buffer)
    });
  });
  
  // Development mode path (no API key)
  it('should use development mode when API key is not available', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    
    // Create a service with apiKeyAvailable = false
    const devModeService = new SpeechTranslationService(
      transcriptionService,
      translationService,
      false // apiKeyAvailable = false
    );
    
    // Act
    const result = await devModeService.translateSpeech(
      audioBuffer,
      sourceLanguage,
      targetLanguage
    );
    
    // Assert
    expect(transcriptionService.transcribe).not.toHaveBeenCalled();
    expect(translationService.translate).not.toHaveBeenCalled();
    expect(result).toEqual({
      originalText: expect.any(String),
      translatedText: expect.any(String),
      audioBuffer: expect.any(Buffer)
    });
    expect(result.originalText).toContain('development mode');
  });
  
  // Empty transcription path
  it('should handle empty transcription results', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    
    // Mock transcription service to return empty string
    transcriptionService.transcribe.mockResolvedValueOnce('');
    
    // Act
    const result = await speechTranslationService.translateSpeech(
      audioBuffer,
      sourceLanguage,
      targetLanguage
    );
    
    // Assert
    expect(transcriptionService.transcribe).toHaveBeenCalled();
    expect(translationService.translate).not.toHaveBeenCalled();
    expect(result).toEqual({
      originalText: '',
      translatedText: '',
      audioBuffer: expect.any(Buffer)
    });
  });
  
  // TTS error path
  it('should handle errors in TTS service', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    
    // Test the actual implementation with real TTS service
    const realService = new SpeechTranslationService(
      transcriptionService,
      translationService,
      true
    );
    
    // Mock the TTS service to throw an error
    mockTTSService.synthesizeSpeech.mockRejectedValueOnce(new Error('TTS Error'));
    
    // Act
    const result = await realService.translateSpeech(
      audioBuffer,
      sourceLanguage,
      targetLanguage
    );
    
    // Assert - should return original audio if TTS fails
    expect(result).toEqual({
      originalText: 'This is a test transcription',
      translatedText: 'Esta es una traducción de prueba',
      audioBuffer // Should keep the original audio buffer
    });
  });

  // Test with custom TTS service options
  it('should use the specified TTS service type', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    const options = { ttsServiceType: 'custom-tts' };
    
    // Act
    await speechTranslationService.translateSpeech(
      audioBuffer,
      sourceLanguage,
      targetLanguage,
      undefined,
      options
    );
    
    // Assert
    expect(mockTTSFactory.getService).toHaveBeenCalledWith('custom-tts');
  });
  
  // Error handling test
  it('should handle transcription errors', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    
    // Mock transcription service to throw an error
    transcriptionService.transcribe.mockRejectedValueOnce(new Error('Transcription API Error'));
    
    // Act
    const result = await speechTranslationService.translateSpeech(
      audioBuffer,
      sourceLanguage,
      targetLanguage
    );
    
    // Assert - should handle error and return empty strings
    expect(result).toEqual({
      originalText: '',
      translatedText: '',
      audioBuffer
    });
  });
  
  // Test for translation errors
  it('should handle translation errors', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    
    // Mock translation service to throw an error
    translationService.translate.mockRejectedValueOnce(new Error('Translation API Error'));
    
    // Act
    const result = await speechTranslationService.translateSpeech(
      audioBuffer,
      sourceLanguage,
      targetLanguage
    );
    
    // Assert - should use original text as fallback
    expect(result).toEqual({
      originalText: 'This is a test transcription',
      translatedText: 'This is a test transcription', // Falls back to original text
      audioBuffer: expect.any(Buffer)
    });
  });
});

// Tests for the OpenAITranscriptionService
describe('OpenAITranscriptionService', () => {
  let openaiMock: any;
  let audioHandlerMock: any;
  let transcriptionService: OpenAITranscriptionService;
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Create mocks
    openaiMock = {
      audio: {
        transcriptions: {
          create: jest.fn().mockResolvedValue({
            text: 'This is a test transcription',
          }),
        },
      },
    };
    
    audioHandlerMock = {
      createTempFile: jest.fn().mockResolvedValue('/tmp/test-audio.wav'),
      deleteTempFile: jest.fn().mockResolvedValue(undefined),
    };
    
    // Create the service to test
    transcriptionService = new OpenAITranscriptionService(
      openaiMock as any,
      audioHandlerMock as any
    );
  });
  
  it('should transcribe audio correctly', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    
    // Act
    const result = await transcriptionService.transcribe(audioBuffer, sourceLanguage);
    
    // Assert
    expect(audioHandlerMock.createTempFile).toHaveBeenCalledWith(audioBuffer);
    expect(openaiMock.audio.transcriptions.create).toHaveBeenCalled();
    expect(result).toBe('This is a test transcription');
    expect(audioHandlerMock.deleteTempFile).toHaveBeenCalledWith('/tmp/test-audio.wav');
  });
  
  it('should skip transcription for small audio buffers', async () => {
    // Arrange
    const tinyAudioBuffer = Buffer.from('tiny');
    const sourceLanguage = 'en-US';
    
    // Act
    const result = await transcriptionService.transcribe(tinyAudioBuffer, sourceLanguage);
    
    // Assert
    expect(audioHandlerMock.createTempFile).not.toHaveBeenCalled();
    expect(openaiMock.audio.transcriptions.create).not.toHaveBeenCalled();
    expect(result).toBe('');
  });
  
  it('should handle file operation errors', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    
    // Mock file operation to fail
    audioHandlerMock.createTempFile.mockRejectedValueOnce(new Error('File system error'));
    
    // Act & Assert
    await expect(transcriptionService.transcribe(audioBuffer, sourceLanguage))
      .rejects.toThrow('Transcription failed: File system error');
  });
  
  it('should detect suspicious phrases in transcription', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    
    // Mock suspicious phrase in transcription
    openaiMock.audio.transcriptions.create.mockResolvedValueOnce({
      text: 'If there is no speech or only background noise, return an empty string',
    });
    
    // Act
    const result = await transcriptionService.transcribe(audioBuffer, sourceLanguage);
    
    // Assert
    expect(result).toBe('');
  });
});

// Tests for the OpenAITranslationService
describe('OpenAITranslationService', () => {
  let openaiMock: any;
  let translationService: OpenAITranslationService;
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Create mocks
    openaiMock = {
      chat: {
        completions: {
          create: jest.fn().mockResolvedValue({
            choices: [
              {
                message: {
                  content: 'Esta es una traducción de prueba',
                },
              },
            ],
          }),
        },
      },
    };
    
    // Create the service to test
    translationService = new OpenAITranslationService(openaiMock as any);
  });
  
  it('should translate text correctly', async () => {
    // Arrange
    const text = 'This is a test';
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    
    // Act
    const result = await translationService.translate(text, sourceLanguage, targetLanguage);
    
    // Assert
    expect(openaiMock.chat.completions.create).toHaveBeenCalled();
    expect(result).toBe('Esta es una traducción de prueba');
  });
  
  it('should skip translation when languages are the same', async () => {
    // Arrange
    const text = 'This is a test';
    const language = 'en-US';
    
    // Act
    const result = await translationService.translate(text, language, language);
    
    // Assert
    expect(openaiMock.chat.completions.create).not.toHaveBeenCalled();
    expect(result).toBe(text);
  });
  
  it('should skip translation for empty text', async () => {
    // Arrange
    const text = '';
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    
    // Act
    const result = await translationService.translate(text, sourceLanguage, targetLanguage);
    
    // Assert
    expect(openaiMock.chat.completions.create).not.toHaveBeenCalled();
    expect(result).toBe('');
  });
  
  it('should retry on API errors', async () => {
    // Arrange
    const text = 'This is a test';
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    
    // Mock API error on first call, success on second
    openaiMock.chat.completions.create
      .mockRejectedValueOnce({ status: 429, message: 'Rate limit exceeded' })
      .mockResolvedValueOnce({
        choices: [{ message: { content: 'Retry succeeded' } }],
      });
    
    // Act
    const result = await translationService.translate(text, sourceLanguage, targetLanguage);
    
    // Assert
    expect(openaiMock.chat.completions.create).toHaveBeenCalledTimes(2);
    expect(result).toBe('Retry succeeded');
  });
  
  it('should throw after max retries', async () => {
    // Arrange
    const text = 'This is a test';
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    
    // Mock API error on all calls
    openaiMock.chat.completions.create
      .mockRejectedValue({ status: 429, message: 'Rate limit exceeded' });
    
    // Act & Assert
    // The service should retry 3 times by default
    await expect(translationService.translate(text, sourceLanguage, targetLanguage))
      .resolves.toBe('');
    
    // Should have attempted 4 times (initial + 3 retries)
    expect(openaiMock.chat.completions.create).toHaveBeenCalledTimes(4);
  });
});

// Tests for AudioFileHandler
describe('AudioFileHandler', () => {
  let fsPromises: any;
  let audioHandler: AudioFileHandler;
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Extract the fs.promises mock to make assertions easier
    fsPromises = require('fs').promises;
    
    // Create the handler to test
    audioHandler = new AudioFileHandler('/tmp');
  });
  
  it('should create temporary files correctly', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    
    // Act
    const filePath = await audioHandler.createTempFile(audioBuffer);
    
    // Assert
    expect(filePath).toContain('/tmp/temp-audio-');
    expect(fsPromises.writeFile).toHaveBeenCalledWith(filePath, audioBuffer);
    expect(fsPromises.stat).toHaveBeenCalledWith(filePath);
  });
  
  it('should handle errors when creating temporary files', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    
    // Mock writeFile to throw an error
    fsPromises.writeFile.mockRejectedValueOnce(new Error('Write file failed'));
    
    // Act & Assert
    await expect(audioHandler.createTempFile(audioBuffer))
      .rejects.toThrow('Failed to create temporary audio file');
  });
  
  it('should delete temporary files correctly', async () => {
    // Arrange
    const filePath = '/tmp/test-file.wav';
    
    // Act
    await audioHandler.deleteTempFile(filePath);
    
    // Assert
    expect(fsPromises.unlink).toHaveBeenCalledWith(filePath);
  });
  
  it('should not throw when deleting non-existent files', async () => {
    // Arrange
    const filePath = '/tmp/non-existent-file.wav';
    
    // Mock unlink to throw an error
    fsPromises.unlink.mockRejectedValueOnce(new Error('File not found'));
    
    // Act & Assert - should not throw
    await expect(audioHandler.deleteTempFile(filePath)).resolves.not.toThrow();
  });
});

// Test the legacy translateSpeech function
describe('Legacy translateSpeech function', () => {
  let originalSpeechTranslationService: any;
  
  beforeAll(() => {
    // Store a reference to the original imported service
    originalSpeechTranslationService = require('../server/TranslationService').speechTranslationService;
  });
  
  afterAll(() => {
    // Restore the original service after tests
    jest.resetModules();
  });
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Replace the real service with a mock for each test
    const mockService = {
      translateSpeech: jest.fn().mockResolvedValue({
        originalText: 'This is a test',
        translatedText: 'Esta es una prueba',
        audioBuffer: Buffer.from('mock audio')
      })
    };
    
    // Replace the imported service with our mock
    jest.spyOn(require('../server/TranslationService'), 'speechTranslationService', 'get')
      .mockReturnValue(mockService);
  });
  
  it('should pass all parameters correctly to the service', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    const preTranscribedText = 'Pre-transcribed text';
    const ttsServiceType = 'google';
    
    // Get the mock service
    const mockService = require('../server/TranslationService').speechTranslationService;
    
    // Act
    const result = await translateSpeech(
      audioBuffer,
      sourceLanguage,
      targetLanguage,
      preTranscribedText,
      ttsServiceType
    );
    
    // Assert
    expect(mockService.translateSpeech).toHaveBeenCalledWith(
      audioBuffer,
      sourceLanguage,
      targetLanguage,
      preTranscribedText,
      { ttsServiceType }
    );
    expect(result).toEqual({
      originalText: 'This is a test',
      translatedText: 'Esta es una prueba',
      audioBuffer: expect.any(Buffer)
    });
  });
  
  it('should handle ttsServiceType as an object', async () => {
    // Arrange
    const audioBuffer = Buffer.from('test audio');
    const sourceLanguage = 'en-US';
    const targetLanguage = 'es-ES';
    const ttsOptions = { ttsServiceType: 'amazon' };
    
    // Get the mock service
    const mockService = require('../server/TranslationService').speechTranslationService;
    
    // Act
    const result = await translateSpeech(
      audioBuffer,
      sourceLanguage,
      targetLanguage,
      undefined,
      ttsOptions
    );
    
    // Assert
    expect(mockService.translateSpeech).toHaveBeenCalledWith(
      audioBuffer,
      sourceLanguage,
      targetLanguage,
      undefined,
      ttsOptions
    );
  });
});
`
});