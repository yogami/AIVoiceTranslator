# Test info

- Name: Analytics Dashboard E2E Tests >> should display formatted metrics correctly
- Location: /Users/yamijala/gitprojects/AIVoiceTranslator/tests/e2e/diagnostics.spec.ts:188:3

# Error details

```
TimeoutError: page.waitForSelector: Timeout 10000ms exceeded.
Call log:
  - waiting for locator('.metric-value') to be visible

    at /Users/yamijala/gitprojects/AIVoiceTranslator/tests/e2e/diagnostics.spec.ts:190:16
```

# Page snapshot

```yaml
- heading "Analytics Dashboard" [level=1]
- link "← Back to Home":
  - /url: /
- paragraph: Real-time usage metrics and adoption analytics for AI Voice Translator
- button "🔄 Refresh Data"
- button "📥 Export Data"
- 'button "⏰ Auto-refresh: OFF"'
- combobox:
  - option "Last 24 Hours" [selected]
  - option "Last 7 Days"
  - option "Last 30 Days"
  - option "All Time"
- text: "Displaying metrics for: Last 24 Hours"
- heading "📊 Product Adoption Metrics" [level=2]
- paragraph: Key metrics for understanding product usage and growth
- heading "Total Sessions" [level=3]
- text: All-time Sessions 0 Active Now 0 Average Duration 0 ms
- heading "Active Users" [level=3]
- text: Teachers Online 0 Students Online 0 Languages in Use 0
- heading "Translation Volume" [level=3]
- text: Total Translations 0 Last Hour 0 Average Latency 0 ms
- heading "📈 Usage Analytics" [level=2]
- paragraph: Translation volume and language pair popularity
- text: No language pair data available yet
- heading "⚡ Performance & Quality Metrics" [level=2]
- paragraph: Technical metrics for monitoring system health and performance
- heading "System Health" [level=3]
- text: Uptime 1.4 minutes Memory Usage 21.7 MB Active Connections 0
- heading "Audio Generation" [level=3]
- text: Total Generated 0 Average Time 0 ms Cache Size 0.0 B
- heading "Real-time Performance" [level=3]
- text: Active Translations 0 Average Latency 0 ms Total Connections 0
- heading "🕐 Recent Session Activity" [level=2]
- paragraph: Latest classroom sessions and their activity
- text: "No recent session activity Last updated: 6/11/2025, 8:37:09 PM"
```

# Test source

```ts
   90 |     // Get initial last updated time
   91 |     const lastUpdated = page.locator('#last-updated');
   92 |     const initialTimeText = await lastUpdated.textContent();
   93 |     
   94 |     // Click refresh button
   95 |     await page.click('#refresh-btn');
   96 |     
   97 |     // Wait a moment for the refresh to process
   98 |     await page.waitForTimeout(500);
   99 |     
  100 |     // Check that last updated time exists
  101 |     const newTime = await lastUpdated.textContent();
  102 |       expect(newTime).toContain('Last updated:');
  103 |   });
  104 |
  105 |   test('should toggle auto-refresh', async () => {
  106 |     const autoRefreshBtn = page.locator('#auto-refresh-btn');
  107 |     
  108 |     // Initially should be OFF
  109 |     await expect(autoRefreshBtn).toContainText('⏰ Auto-refresh: OFF');
  110 |     await expect(autoRefreshBtn).not.toHaveClass('auto-refresh-on');
  111 |     
  112 |     // Click to enable
  113 |     await autoRefreshBtn.click();
  114 |     await expect(autoRefreshBtn).toContainText('⏰ Auto-refresh: ON');
  115 |     await expect(autoRefreshBtn).toHaveClass(/auto-refresh-on/);
  116 |
  117 |     // Click to disable
  118 |     await autoRefreshBtn.click();
  119 |     await expect(autoRefreshBtn).toContainText('⏰ Auto-refresh: OFF');
  120 |     await expect(autoRefreshBtn).not.toHaveClass('auto-refresh-on');
  121 |   });
  122 |
  123 |   test('should export data when export button is clicked', async () => {
  124 |     // Set up download promise before clicking
  125 |     const downloadPromise = page.waitForEvent('download');
  126 |     
  127 |     // Click export button
  128 |     await page.click('#export-btn');
  129 |     
  130 |     // Wait for download
  131 |     const download = await downloadPromise;
  132 |     
  133 |     // Verify download
  134 |     expect(download.suggestedFilename()).toMatch(/analytics-export-\d{4}-\d{2}-\d{2}\.json/);
  135 |   });
  136 |
  137 |   test('should display language pair metrics table or no data message', async () => {
  138 |     // Wait for usage analytics section to load
  139 |     await page.waitForSelector('#usage-analytics', { timeout: 5000 });
  140 |     
  141 |     // Check if table exists or no data message is shown
  142 |     const tableExists = await page.locator('.language-pairs-table').count() > 0;
  143 |     const noDataExists = await page.locator('.no-data').count() > 0;
  144 |     
  145 |     // Either table or no data message should be present
  146 |     expect(tableExists || noDataExists).toBeTruthy();
  147 |     
  148 |     if (tableExists) {
  149 |       // Check table headers
  150 |       const headers = page.locator('.language-pairs-table th');
  151 |       await expect(headers).toHaveCount(4);
  152 |       await expect(headers.nth(0)).toContainText('Source Language');
  153 |       await expect(headers.nth(1)).toContainText('Target Language');
  154 |       await expect(headers.nth(2)).toContainText('Translation Count');
  155 |       await expect(headers.nth(3)).toContainText('Average Latency');
  156 |     }
  157 |   });
  158 |
  159 |   test('should handle API errors gracefully', async ({ page }) => {
  160 |     // 1. Let the page load normally first (handled by beforeEach)
  161 |     // Ensure basic page structure is present before we mess with API calls
  162 |     await expect(page).toHaveTitle('Analytics Dashboard - AIVoiceTranslator', { timeout: 10000 });
  163 |     await expect(page.locator('h1')).toContainText('Analytics Dashboard', { timeout: 5000 });
  164 |
  165 |     // 2. Intercept the *next* API call only and return an error
  166 |     await page.route('/api/diagnostics**/*', async route => {
  167 |       await route.fulfill({
  168 |         status: 500,
  169 |         contentType: 'application/json',
  170 |         body: JSON.stringify({ message: 'Internal Server Error from mock' }) // Ensure body gives a message
  171 |       });
  172 |     }, { times: 1 }); // Apply only once
  173 |
  174 |     // 3. Trigger the API call by clicking the refresh button
  175 |     await page.locator('#refresh-btn').click();
  176 |     
  177 |     // 4. Wait for the error container to become visible
  178 |     const errorContainerLocator = page.locator('#error-container');
  179 |     await expect(errorContainerLocator).toBeVisible({ timeout: 10000 });
  180 |     
  181 |     // 5. Check the error message text
  182 |     // Based on frontend logic: `Failed to load diagnostics data.: HTTP error! status: 500: ${response.text()}`
  183 |     // response.text() will be `{"message":"Internal Server Error from mock"}`
  184 |     const errorMessageLocator = errorContainerLocator.locator('.error-message');
  185 |     await expect(errorMessageLocator).toContainText('Failed to load diagnostics data.: HTTP error! status: 500: {\"message\":\"Internal Server Error from mock\"}', { timeout: 5000 });
  186 |   });
  187 |
  188 |   test('should display formatted metrics correctly', async ({ page }) => {
  189 |     // Wait for metrics to load
> 190 |     await page.waitForSelector('.metric-value', { timeout: 10000 }); // Increased timeout
      |                ^ TimeoutError: page.waitForSelector: Timeout 10000ms exceeded.
  191 |     
  192 |     // Check that metrics are formatted
  193 |     const metricValues = page.locator('.metric-value');
  194 |     const count = await metricValues.count();
  195 |     
  196 |     // At least some metrics should be displayed
  197 |     expect(count).toBeGreaterThan(0);
  198 |     
  199 |     // Check specific formatting
  200 |     const firstValue = await metricValues.first().textContent();
  201 |     expect(firstValue).toBeTruthy();
  202 |   });
  203 |
  204 |   test('should navigate back to home', async () => {
  205 |     // Click back to home link
  206 |     await page.click('a:has-text("Back to Home")');
  207 |     
  208 |     // Should navigate to home page
  209 |     await expect(page).toHaveURL('/');
  210 |   });
  211 |
  212 |   test('should be responsive on mobile', async () => {
  213 |     // Set mobile viewport
  214 |     await page.setViewportSize({ width: 375, height: 667 });
  215 |     
  216 |     // Check that layout adapts - use first metrics grid
  217 |     const metricsGrid = page.locator('.metrics-grid').first();
  218 |     const gridStyleValue = await metricsGrid.evaluate((el: HTMLElement) => 
  219 |       window.getComputedStyle(el).gridTemplateColumns
  220 |     );
  221 |     
  222 |     // Should be single column on mobile (either '1fr' or a single pixel value)
  223 |     const isSingleColumn = gridStyleValue === '1fr' || 
  224 |                           (gridStyleValue.match(/^\d+px$/) !== null && !gridStyleValue.includes(' '));
  225 |     expect(isSingleColumn).toBeTruthy();
  226 |     
  227 |     // Buttons should stack vertically
  228 |     const controls = page.locator('.controls');
  229 |     const controlsStyle = await controls.evaluate((el: HTMLElement) => 
  230 |       window.getComputedStyle(el).flexDirection
  231 |     );
  232 |     expect(controlsStyle).toBe('column');
  233 |   });
  234 |
  235 |   test('should display recent session activity', async () => {
  236 |     // Wait for recent activity section
  237 |     await page.waitForSelector('#recent-activity', { timeout: 10000 }); // Increased timeout
  238 |     
  239 |     const recentActivity = page.locator('#recent-activity');
  240 |     const content = await recentActivity.textContent();
  241 |     
  242 |     // Should either show sessions or "no data" message
  243 |     expect(content).toMatch(/Recent Sessions|No recent session activity/);
  244 |   });
  245 |
  246 |   test('should update metrics in real-time when auto-refresh is enabled', async () => {
  247 |     // Enable auto-refresh
  248 |     await page.click('#auto-refresh-btn');
  249 |     
  250 |     // Get initial last updated time
  251 |     const lastUpdated = page.locator('#last-updated');
  252 |     const initialTimeText = await lastUpdated.textContent();
  253 |     
  254 |     // Wait for auto-refresh (5 seconds + buffer)
  255 |     await page.waitForTimeout(6000);
  256 |     
  257 |     // Check that last updated time exists (may or may not have changed in test environment)
  258 |     const updatedTime = await lastUpdated.textContent();
  259 |     expect(updatedTime).toContain('Last updated:');
  260 |   });
  261 |
  262 |   test('should display connection metrics correctly', async () => {
  263 |     // Wait for metrics to load
  264 |     await page.waitForSelector('.metric-card', { timeout: 5000 });
  265 |     
  266 |     // Find the Active Users card which contains connection info
  267 |     const activeUsersCard = page.locator('.metric-card:has-text("Active Users")');
  268 |     await expect(activeUsersCard).toBeVisible();
  269 |     
  270 |     // Check that it contains connection-related metrics
  271 |     await expect(activeUsersCard).toContainText('Teachers Online');
  272 |     await expect(activeUsersCard).toContainText('Students Online');
  273 |     await expect(activeUsersCard).toContainText('Languages in Use');
  274 |   });
  275 |
  276 |   test('should display session metrics correctly', async () => {
  277 |     // Wait for metrics to load
  278 |     await page.waitForSelector('.metric-card', { timeout: 5000 });
  279 |     
  280 |     // Find the Total Sessions card
  281 |     const sessionsCard = page.locator('.metric-card:has-text("Total Sessions")');
  282 |     await expect(sessionsCard).toBeVisible();
  283 |     
  284 |     // Check that it contains session-related metrics
  285 |     await expect(sessionsCard).toContainText('All-time Sessions');
  286 |     await expect(sessionsCard).toContainText('Active Now');
  287 |     await expect(sessionsCard).toContainText('Average Duration');
  288 |   });
  289 |
  290 |   test('should display translation metrics correctly', async () => {
```