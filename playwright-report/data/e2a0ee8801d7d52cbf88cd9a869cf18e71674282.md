# Test info

- Name: Teacher Interface E2E Tests >> should handle recording controls
- Location: /Users/yamijala/gitprojects/AIVoiceTranslator/tests/e2e/teacher.spec.ts:51:3

# Error details

```
Error: Timed out 5000ms waiting for expect(locator).toBeDisabled()

Locator: locator('#record-btn')
Expected: disabled
Received: enabled
Call log:
  - expect.toBeDisabled with timeout 5000ms
  - waiting for locator('#record-btn')
    9 × locator resolved to <button id="record-btn" class="record-btn">Start Recording</button>
      - unexpected value "enabled"

    at /Users/yamijala/gitprojects/AIVoiceTranslator/tests/e2e/teacher.spec.ts:61:47
```

# Page snapshot

```yaml
- link "← Back to Home":
  - /url: /
- heading "Teacher Interface" [level=1]
- text: ✓ Connected to server Speech recognition not available
- combobox:
  - option "English (US)" [selected]
  - option "Spanish"
  - option "French"
  - option "German"
  - option "Chinese"
  - option "Japanese"
- text: Ready to record
- button "Start Recording"
- button "Stop Recording" [disabled]
- text: Your speech will appear here...
```

# Test source

```ts
   1 | /**
   2 |  * Teacher Interface E2E Test
   3 |  * 
   4 |  * This test checks the functionality of the teacher interface.
   5 |  */
   6 |
   7 | import { test, expect, Page } from '@playwright/test';
   8 |
   9 | test.describe('Teacher Interface E2E Tests', () => {
   10 |   let page: Page;
   11 |
   12 |   test.beforeEach(async ({ browser }) => {
   13 |     page = await browser.newPage();
   14 |     await page.goto('/teacher');
   15 |   });
   16 |
   17 |   test.afterEach(async () => {
   18 |     await page.close();
   19 |   });
   20 |
   21 |   test('should display initial UI elements correctly', async () => {
   22 |     // Check essential elements
   23 |     await expect(page.locator('h1')).toContainText('Teacher Interface');
   24 |     await expect(page.locator('#connection-status')).toBeVisible();
   25 |     await expect(page.locator('#language-select')).toBeVisible();
   26 |     await expect(page.locator('#record-btn')).toBeVisible();
   27 |     await expect(page.locator('#stop-btn')).toBeVisible();
   28 |     await expect(page.locator('#stop-btn')).toBeDisabled();
   29 |     await expect(page.locator('#transcript-text')).toBeVisible();
   30 |   });
   31 |
   32 |   test('should establish WebSocket connection automatically', async () => {
   33 |     // Wait for auto-connection
   34 |     await expect(page.locator('#connection-status')).toContainText('Connected', { timeout: 5000 });
   35 |     await expect(page.locator('#connection-status')).toHaveClass(/connected/);
   36 |   });
   37 |
   38 |   test('should handle language selection', async () => {
   39 |     // Wait for connection first
   40 |     await expect(page.locator('#connection-status')).toContainText('Connected', { timeout: 5000 });
   41 |     
   42 |     // Change language
   43 |     await page.selectOption('#language-select', 'es-ES');
   44 |     const selectedValue = await page.locator('#language-select').inputValue();
   45 |     expect(selectedValue).toBe('es-ES');
   46 |     
   47 |     // Should re-register with new language
   48 |     await page.waitForTimeout(1000); // Wait for re-registration
   49 |   });
   50 |
   51 |   test('should handle recording controls', async () => {
   52 |     // Check initial state
   53 |     await expect(page.locator('#record-btn')).toBeEnabled();
   54 |     await expect(page.locator('#stop-btn')).toBeDisabled();
   55 |     await expect(page.locator('#status')).toContainText('Ready to record');
   56 |     
   57 |     // Start recording
   58 |     await page.click('#record-btn');
   59 |     
   60 |     // Check recording state
>  61 |     await expect(page.locator('#record-btn')).toBeDisabled();
      |                                               ^ Error: Timed out 5000ms waiting for expect(locator).toBeDisabled()
   62 |     await expect(page.locator('#stop-btn')).toBeEnabled();
   63 |     await expect(page.locator('#status')).toContainText('Recording');
   64 |     await expect(page.locator('#transcript-text')).toContainText('Listening');
   65 |     
   66 |     // Stop recording
   67 |     await page.click('#stop-btn');
   68 |     
   69 |     // Check stopped state
   70 |     await expect(page.locator('#record-btn')).toBeEnabled();
   71 |     await expect(page.locator('#stop-btn')).toBeDisabled();
   72 |     await expect(page.locator('#status')).toContainText('Ready to record');
   73 |   });
   74 |
   75 |   test.skip('should handle connection loss and reconnection', async () => {
   76 |     // Skip this test as it's difficult to reliably simulate network disconnection
   77 |     // without interfering with the application's normal operation.
   78 |     // The WebSocket reconnection logic can be tested in integration tests instead.
   79 |   });
   80 |
   81 |   test('should display errors when speech recognition unavailable', async ({ browser }) => {
   82 |     // Create a new context with speech recognition disabled
   83 |     const context = await browser.newContext();
   84 |     const newPage = await context.newPage();
   85 |     
   86 |     // Disable speech recognition before navigating
   87 |     await newPage.addInitScript(() => {
   88 |       (window as any).SpeechRecognition = undefined;
   89 |       (window as any).webkitSpeechRecognition = undefined;
   90 |     });
   91 |     
   92 |     // Navigate to teacher page
   93 |     await newPage.goto('/teacher');
   94 |     
   95 |     // Wait a moment for initialization
   96 |     await newPage.waitForTimeout(1000);
   97 |     
   98 |     // The error message should be visible and contain the error text
   99 |     const errorElement = newPage.locator('#error-message');
  100 |     
  101 |     // Check if the element has the error text (it might be hidden by default but contain text)
  102 |     const errorText = await errorElement.textContent();
  103 |     expect(errorText).toContain('Speech recognition not supported');
  104 |     
  105 |     // Also check if the element is visible by checking its display style
  106 |     const isVisible = await errorElement.evaluate(el => {
  107 |       const style = window.getComputedStyle(el);
  108 |       return style.display !== 'none' && style.visibility !== 'hidden';
  109 |     });
  110 |     
  111 |     // If the error is shown immediately, it should be visible
  112 |     // Otherwise, just verify the text content exists
  113 |     if (isVisible) {
  114 |       await expect(errorElement).toBeVisible();
  115 |     }
  116 |     
  117 |     await newPage.close();
  118 |     await context.close();
  119 |   });
  120 | });
```