<!DOCTYPE html>
<!-- 
    AIVoiceTranslator Student Interface
    
    Architecture Note: TTS service selection is now controlled by the teacher.
    Students can see which TTS service is active but cannot change it.
    They can play examples of different TTS services for comparison only.
    
    The architecture follows these principles:
    - Centralized control by the teacher for classroom consistency
    - Read-only display of TTS service selection for students
    - TTS comparison capabilities for educational purposes
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Student View - AIVoiceTranslator</title>
    
    <!-- Autoplay Permission Handler -->
    <script>
        // This script runs immediately to request audio permission as early as possible
        window.browserTTSPermissionGranted = false;
        
        function requestAudioPermission() {
            try {
                // Create and play a silent audio element to satisfy user interaction requirement
                const silentAudio = new Audio("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
                silentAudio.volume = 0.01; // Almost silent
                
                // When user clicks anywhere, try to play it
                document.addEventListener('click', function audioPermissionHandler() {
                    silentAudio.play().then(() => {
                        console.log("✅ Audio permission granted");
                        window.browserTTSPermissionGranted = true;
                        
                        // Also initialize speech synthesis
                        if ('speechSynthesis' in window) {
                            const tinyUtterance = new SpeechSynthesisUtterance('.');
                            tinyUtterance.volume = 0;
                            tinyUtterance.rate = 10;
                            window.speechSynthesis.speak(tinyUtterance);
                            window.speechSynthesis.cancel();
                            console.log("Speech synthesis initialized");
                        }
                        
                        // Remove this event listener once permission is granted
                        document.removeEventListener('click', audioPermissionHandler);
                        
                        // Hide the permission banner if it exists
                        const banner = document.getElementById('permission-banner');
                        if (banner) banner.style.display = 'none';
                    }).catch(err => {
                        console.log("❌ Audio permission denied:", err);
                    });
                }, { once: false });
                
                // Show permission request banner after page loads
                document.addEventListener('DOMContentLoaded', function() {
                    const permissionBanner = document.createElement('div');
                    permissionBanner.id = 'permission-banner';
                    permissionBanner.style.position = 'fixed';
                    permissionBanner.style.top = '0';
                    permissionBanner.style.left = '0';
                    permissionBanner.style.right = '0';
                    permissionBanner.style.backgroundColor = '#f8d7da';
                    permissionBanner.style.color = '#721c24';
                    permissionBanner.style.padding = '10px';
                    permissionBanner.style.textAlign = 'center';
                    permissionBanner.style.zIndex = '10'; // Much lower z-index to not block buttons
                    permissionBanner.style.display = 'block';
                    permissionBanner.innerHTML = '<strong>Please click anywhere on this page</strong> to enable automatic audio playback. This is required for the translation system to work properly.';
                    
                    document.body.appendChild(permissionBanner);
                });
            } catch (e) {
                console.error("Error setting up audio permission:", e);
            }
        }
        
        // Initialize permission request
        requestAudioPermission();
    </script>
    
    <script src="js/language-support.js"></script>
    <style>
        :root {
            --primary-color: #3498db;
            --primary-dark: #2980b9;
            --primary-light: #e8f4fd;
            --secondary-color: #2ecc71;
            --secondary-dark: #27ae60;
            --error-color: #e74c3c;
            --warning-color: #f39c12;
            --text-color: #2c3e50;
            --text-light: #7f8c8d;
            --bg-color: #f5f8fa;
            --card-bg: white;
            --border-radius: 12px;
            --shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
        }
        
        /* Responsive Typography */
        html {
            font-size: 16px;
        }
        
        @media (max-width: 768px) {
            html {
                font-size: 14px;
            }
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s ease;
        }
        
        h1 {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 1.5rem;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 1px 1px rgba(0,0,0,0.05);
        }
        
        .container {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--shadow);
            margin-bottom: 30px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid rgba(0,0,0,0.05);
        }
        
        .container:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.12);
        }
        .translation-box {
            min-height: 150px;
            border: 1px solid rgba(0, 0, 0, 0.09);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 25px;
            background-color: #f9fafc;
            font-size: 1.2rem;
            line-height: 1.6;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }
        
        .translation-box:empty:before {
            content: "Teacher's speech will appear here...";
            color: var(--text-light);
            font-style: italic;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .translation-box:focus {
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05), 0 0 0 3px rgba(52, 152, 219, 0.3);
            outline: none;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        select {
            padding: 12px 15px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            font-size: 1rem;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
            color: var(--text-color);
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23131313%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 15px top 50%;
            background-size: 12px auto;
            padding-right: 30px;
        }
        
        select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.25);
            outline: none;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
        }
        
        button:disabled {
            background-color: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            font-weight: 600;
            font-size: 1.1rem;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: var(--border-radius);
            transition: background-color 0.3s ease;
        }
        
        .status.active {
            background-color: rgba(46, 204, 113, 0.1);
        }
        
        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
            position: relative;
        }
        
        .indicator.connected {
            background-color: var(--secondary-color);
            box-shadow: 0 0 0 rgba(46, 204, 113, 0.4);
            animation: pulse 2s infinite;
        }
        
        .indicator.disconnected {
            background-color: var(--error-color);
        }
        
        .indicator.connected:after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            border: 2px solid var(--secondary-color);
            opacity: 0.6;
            animation: pulse-ring 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        .language-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        
        .language-heading {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 12px;
            width: 100%;
            color: var(--text-color);
            border-bottom: 1px solid rgba(0,0,0,0.05);
            padding-bottom: 8px;
        }
        
        .language-btn {
            padding: 10px 16px;
            background-color: white;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 30px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .language-btn:hover:not(.unsupported) {
            background-color: var(--primary-light);
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 3px 5px rgba(0,0,0,0.08);
        }
        
        .language-btn.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-dark);
            box-shadow: 0 3px 5px rgba(0,0,0,0.1);
        }
        
        .language-btn.unsupported {
            opacity: 0.5;
            background-color: #f8f9fa;
            border-color: #e9ecef;
            cursor: not-allowed;
            position: relative;
        }
        
        .language-btn.unsupported:hover {
            background-color: #f8f9fa;
            border-color: #e9ecef;
            transform: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .language-btn.unsupported:after {
            content: '⚠️';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 10px;
            background: var(--warning-color);
            color: white;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .debug-log {
            margin-top: 30px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            background-color: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .log-entry {
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px dashed rgba(255,255,255,0.1);
        }
        
        .log-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        /* Modal styling */
        .language-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.75);
            z-index: 1000;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .language-modal.show {
            opacity: 1;
        }
        
        .language-modal .modal-content {
            position: relative;
            width: 90%;
            max-width: 900px;
            max-height: 85vh;
            overflow-y: auto;
            margin: 5% auto;
            background: white;
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transform: translateY(-20px);
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .language-modal.show .modal-content {
            transform: translateY(0);
            opacity: 1;
        }
        
        .language-modal .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .language-modal .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-color);
            margin: 0;
        }
        
        .language-modal .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.05);
            border: none;
            font-size: 22px;
            font-weight: bold;
            cursor: pointer;
            color: var(--text-color);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .language-modal .close-button:hover {
            background: rgba(0,0,0,0.1);
            transform: rotate(90deg);
        }
        
        .language-search {
            padding: 12px 15px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(0,0,0,0.1);
            font-size: 1rem;
            width: 100%;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .language-search:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(52,152,219,0.25);
            outline: none;
        }
        
        .language-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        
        .language-group {
            margin-bottom: 25px;
        }
        
        .language-group-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            color: var(--text-color);
        }
        
        .expanded-language-btn {
            padding: 12px 15px;
            text-align: left;
            background: white;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            font-weight: 500;
            position: relative;
        }
        
        .expanded-language-btn:hover:not(.unsupported) {
            background: var(--primary-light);
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 3px 5px rgba(0,0,0,0.08);
        }
        
        .expanded-language-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-dark);
            box-shadow: 0 3px 5px rgba(0,0,0,0.1);
        }
        
        .expanded-language-btn.unsupported {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #f8f9fa;
            position: relative;
        }
        
        .expanded-language-btn.unsupported:after {
            content: '⚠️';
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 10px;
            opacity: 0.8;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .header-links {
            display: flex;
            gap: 20px;
        }
        
        .header a {
            font-size: 0.95rem;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .header a:hover {
            color: var(--primary-dark);
        }
        
        .header a:after {
            content: '';
            position: absolute;
            width: 0;
            height: 2px;
            bottom: -5px;
            left: 0;
            background-color: var(--primary-color);
            transition: width 0.2s ease;
        }
        
        .header a:hover:after {
            width: 100%;
        }
        
        .messages {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: var(--border-radius);
            padding: 15px;
            margin-top: 20px;
            background-color: white;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .message {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            line-height: 1.4;
        }
        
        .message:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .error-message {
            background-color: rgba(231, 76, 60, 0.1);
            color: #c0392b;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            border-left: 4px solid var(--error-color);
            font-weight: 500;
        }
        
        .success-message {
            background-color: rgba(46, 204, 113, 0.1);
            color: #27ae60;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            border-left: 4px solid var(--secondary-color);
            font-weight: 500;
        }
        
        .audio-controls {
            margin-top: 25px;
            margin-bottom: 25px;
            display: flex;
            justify-content: center;
        }
        
        #play-button {
            background-color: var(--primary-dark);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.2s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }
        
        #play-button:hover {
            background-color: var(--primary-color);
            transform: translateY(-3px);
            box-shadow: 0 5px 12px rgba(0,0,0,0.2);
        }
        
        #play-button:active {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        
        #play-button:disabled {
            background-color: rgba(0,0,0,0.2);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .play-icon {
            font-size: 1.1rem;
        }
        
        @keyframes pulse-ring {
            0% {
                transform: scale(0.95);
                opacity: 0.7;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.3;
            }
            100% {
                transform: scale(0.95);
                opacity: 0.7;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Student Translator</h1>
        <div class="header-links">
            <a href="/"><span>←</span> Back to Home</a>
            <a href="/code-metrics.html">Code Quality Dashboard</a>
        </div>
    </div>
    
    <div class="container">
        <div id="error-container"></div>
        <div id="success-container"></div>
        
        <div class="status">
            <span id="connection-indicator" class="indicator disconnected"></span>
            <span id="connection-status">Disconnected</span>
        </div>
        
        <div class="controls">
            <select id="language-select">
                <optgroup label="Most Common Languages">
                    <option value="es">Spanish (Español)</option>
                    <option value="fr">French (Français)</option>
                    <option value="de">German (Deutsch)</option>
                    <option value="it">Italian (Italiano)</option>
                    <option value="zh">Chinese (中文)</option>
                    <option value="ja">Japanese (日本語)</option>
                    <option value="ru">Russian (Русский)</option>
                    <option value="ar">Arabic (العربية)</option>
                    <option value="pt">Portuguese (Português)</option>
                    <option value="ko">Korean (한국어)</option>
                </optgroup>
                <optgroup label="European Languages">
                    <option value="bg">Bulgarian (български)</option>
                    <option value="cs">Czech (Čeština)</option>
                    <option value="da">Danish (Dansk)</option>
                    <option value="nl">Dutch (Nederlands)</option>
                    <option value="et">Estonian (Eesti)</option>
                    <option value="fi">Finnish (Suomi)</option>
                    <option value="el">Greek (Ελληνικά)</option>
                    <option value="hu">Hungarian (Magyar)</option>
                    <option value="is">Icelandic (Íslenska)</option>
                    <option value="ga">Irish (Gaeilge)</option>
                    <option value="lv">Latvian (Latviešu)</option>
                    <option value="lt">Lithuanian (Lietuvių)</option>
                    <option value="no">Norwegian (Norsk)</option>
                    <option value="pl">Polish (Polski)</option>
                    <option value="ro">Romanian (Română)</option>
                    <option value="sk">Slovak (Slovenčina)</option>
                    <option value="sl">Slovenian (Slovenščina)</option>
                    <option value="sv">Swedish (Svenska)</option>
                    <option value="uk">Ukrainian (Українська)</option>
                </optgroup>
                <optgroup label="Asian Languages">
                    <option value="bn">Bengali (বাংলা)</option>
                    <option value="hi">Hindi (हिन्दी)</option>
                    <option value="id">Indonesian (Bahasa Indonesia)</option>
                    <option value="ms">Malay (Bahasa Melayu)</option>
                    <option value="fa">Persian (فارسی)</option>
                    <option value="tl">Filipino (Tagalog)</option>
                    <option value="ta">Tamil (தமிழ்)</option>
                    <option value="te">Telugu (తెలుగు)</option>
                    <option value="th">Thai (ไทย)</option>
                    <option value="tr">Turkish (Türkçe)</option>
                    <option value="ur">Urdu (اردو)</option>
                    <option value="vi">Vietnamese (Tiếng Việt)</option>
                </optgroup>
                <optgroup label="African Languages">
                    <option value="am">Amharic (አማርኛ)</option>
                    <option value="ha">Hausa (هَوُسَ)</option>
                    <option value="ig">Igbo (Igbo)</option>
                    <option value="sw">Swahili (Kiswahili)</option>
                    <option value="yo">Yoruba (Yorùbá)</option>
                    <option value="zu">Zulu (isiZulu)</option>
                </optgroup>
                <optgroup label="Language Variants">
                    <option value="en-US">English (United States)</option>
                    <option value="en-GB">English (United Kingdom)</option>
                    <option value="en-AU">English (Australia)</option>
                    <option value="en-IN">English (India)</option>
                    <option value="es-ES">Spanish (Spain)</option>
                    <option value="es-MX">Spanish (Mexico)</option>
                    <option value="es-419">Spanish (Latin America)</option>
                    <option value="fr-FR">French (France)</option>
                    <option value="fr-CA">French (Canada)</option>
                    <option value="pt-BR">Portuguese (Brazil)</option>
                    <option value="pt-PT">Portuguese (Portugal)</option>
                    <option value="zh-CN">Chinese (Simplified)</option>
                    <option value="zh-TW">Chinese (Traditional)</option>
                    <option value="ar-XA">Arabic (Multiple Regions)</option>
                </optgroup>
                <optgroup label="Other Languages">
                    <option value="af">Afrikaans</option>
                    <option value="sq">Albanian (Shqip)</option>
                    <option value="hy">Armenian (հայերեն)</option>
                    <option value="az">Azerbaijani (Azərbaycan)</option>
                    <option value="eu">Basque (Euskara)</option>
                    <option value="be">Belarusian (беларуская)</option>
                    <option value="ca">Catalan (Català)</option>
                    <option value="hr">Croatian (Hrvatski)</option>
                    <option value="eo">Esperanto</option>
                    <option value="gl">Galician (Galego)</option>
                    <option value="ka">Georgian (ქართული)</option>
                    <option value="gu">Gujarati (ગુજરાતી)</option>
                    <option value="he">Hebrew (עברית)</option>
                    <option value="jv">Javanese (Basa Jawa)</option>
                    <option value="kn">Kannada (ಕನ್ನಡ)</option>
                    <option value="kk">Kazakh (Қазақ)</option>
                    <option value="km">Khmer (ខ្មែរ)</option>
                    <option value="lo">Lao (ລາວ)</option>
                    <option value="mk">Macedonian (македонски)</option>
                    <option value="ml">Malayalam (മലയാളം)</option>
                    <option value="mr">Marathi (मराठी)</option>
                    <option value="mn">Mongolian (монгол)</option>
                    <option value="my">Myanmar (Burmese) (မြန်မာ)</option>
                    <option value="ne">Nepali (नेपाली)</option>
                    <option value="pa">Punjabi (ਪੰਜਾਬੀ)</option>
                    <option value="si">Sinhala (සිංහල)</option>
                    <option value="so">Somali (Soomaali)</option>
                    <option value="su">Sundanese (Basa Sunda)</option>
                    <option value="cy">Welsh (Cymraeg)</option>
                    <option value="yi">Yiddish (ייִדיש)</option>
                </optgroup>
            </select>
            <button id="connect-btn">Connect</button>
            <button id="disconnect-btn" disabled>Disconnect</button>
        </div>
        
        <div>
            <div class="language-heading">Quick Language Selection</div>
            <div class="language-list">
                <div class="language-btn" data-lang="es">Spanish</div>
                <div class="language-btn" data-lang="fr">French</div>
                <div class="language-btn" data-lang="de">German</div>
                <div class="language-btn" data-lang="it">Italian</div>
                <div class="language-btn" data-lang="zh">Chinese</div>
                <div class="language-btn" data-lang="ja">Japanese</div>
                <div class="language-btn" data-lang="ru">Russian</div>
                <div class="language-btn" data-lang="ar">Arabic</div>
                <div class="language-btn" data-lang="hi">Hindi</div>
                <div class="language-btn" data-lang="pt">Portuguese</div>
                <button id="show-more-languages" style="background-color: var(--warning-color); color: white; font-size: 0.95rem; padding: 10px 16px; font-weight: 500; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                    <span>⋯</span> More Languages
                </button>
            </div>
        </div>
        
        <!-- Expanded Language Selection Modal -->
        <div id="language-modal" class="language-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">Choose Your Language</h2>
                    <button id="close-modal" class="close-button">×</button>
                </div>
                
                <input type="text" class="language-search" id="language-search" placeholder="Search for a language...">
                
                <div id="expanded-language-list" class="language-grid">
                    <!-- This will be populated dynamically -->
                </div>
            </div>
        </div>
        
        <div class="container" style="margin-top: 30px;">
            <div class="language-heading">Text-to-Speech Information</div>
            
            <div id="tts-service-info" style="margin-top: 15px;">
                <div id="active-tts-service-container" style="background-color: rgba(52, 152, 219, 0.1); border-left: 4px solid var(--primary-color); padding: 20px; border-radius: var(--border-radius); margin-bottom: 20px;">
                    <h3 style="margin-top: 0; color: var(--primary-color); font-size: 1.1rem;">Teacher-Controlled TTS Service</h3>
                    <p style="margin-bottom: 10px;">
                        <span id="active-tts-service">The Text-to-Speech service is controlled by the teacher.</span> Your current TTS service is:
                        <span id="current-tts-service" style="font-weight: bold; font-size: 1.1rem; color: var(--primary-color); display: inline-block; margin-left: 8px; padding: 3px 12px; background-color: rgba(52, 152, 219, 0.1); border-radius: 20px;">Browser</span>
                    </p>
                    <p style="margin-bottom: 0; font-size: 0.9rem; color: var(--text-light);">
                        Only the teacher can change the TTS service. All students will automatically use the same service.
                    </p>
                </div>
                
                <!-- TTS Service Comparison section removed -->
            </div>
        </div>
        
        <div class="container" style="margin-top: 30px;">
            <div class="language-heading">Translated Speech</div>
            <div id="translation-box" class="translation-box">
                <p>Connect and select a language to receive translated speech from the teacher.</p>
            </div>
            
            <div class="audio-controls">
                <audio id="audio-player" controls style="display: none;"></audio>
                <button id="play-button" disabled>
                    <span class="play-icon">▶</span> Play Translation
                </button>
            </div>
        </div>
        
        <!-- Audio Comparison Section Removed -->
        
        <div class="container" style="margin-top: 30px;">
            <div class="language-heading">Connection Messages</div>
            <div id="messages" class="messages"></div>
        </div>
    </div>
    
    <div class="debug-log">
        <h3>Debug Log:</h3>
        <div id="log"></div>
    </div>
    
    <!-- Language support module -->
    <script src="/js/language-support.js"></script>
    
    <script>
        // Debug logging
        function log(message) {
            const logContainer = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(message);
        }
        
        // Show error message
        function showError(message) {
            const errorContainer = document.getElementById('error-container');
            errorContainer.innerHTML = `<div class="error-message">${message}</div>`;
            setTimeout(() => {
                errorContainer.innerHTML = '';
            }, 5000);
        }
        
        // Show success message
        function showSuccess(message) {
            const successContainer = document.getElementById('success-container');
            successContainer.innerHTML = `<div class="success-message">${message}</div>`;
            setTimeout(() => {
                successContainer.innerHTML = '';
            }, 5000);
        }
        
        // WebSocket Variables
        let socket;
        let isConnected = false;
        let sessionId = null;
        let selectedLanguage = document.getElementById('language-select').value;
        
        // Audio Cache - Store audio data by text and TTS service
        let audioCache = {
            lastTranslation: {
                text: "",
                originalText: "",
                audios: {}  // { "browser": { data: base64, url: blobUrl }, "openai": {...} }
            }
        };
        
        // Initialize browser speech synthesis on page load 
        // This is to work around browser security restrictions that require user interaction
        let speechSynthesisInitialized = false;
        
        // Function to initialize browser speech synthesis
        function initializeSpeechSynthesis() {
            if ('speechSynthesis' in window && !speechSynthesisInitialized) {
                try {
                    // Create a short, silent utterance
                    const silentUtterance = new SpeechSynthesisUtterance('.');
                    silentUtterance.volume = 0; // Make it silent
                    silentUtterance.rate = 10; // Make it extremely fast
                    
                    // Speak the silent utterance to initialize the speech synthesis engine
                    window.speechSynthesis.speak(silentUtterance);
                    window.speechSynthesis.cancel(); // Cancel it immediately
                    
                    log('🎵 Browser speech synthesis initialized on page load');
                    speechSynthesisInitialized = true;
                    
                    // Also periodically resume speech synthesis to prevent Chrome from pausing it
                    setInterval(() => {
                        try {
                            if (window.speechSynthesis) {
                                window.speechSynthesis.resume();
                            }
                        } catch (e) {
                            // Ignore errors
                        }
                    }, 5000);
                    
                    return true;
                } catch (error) {
                    log('⚠️ Failed to initialize speech synthesis: ' + error.message);
                    return false;
                }
            }
            return false;
        }
        
        // Try to initialize speech synthesis on page load
        document.addEventListener('DOMContentLoaded', initializeSpeechSynthesis);
        
        // Try to initialize speech synthesis on first click anywhere on the page
        document.addEventListener('click', function() {
            if (!speechSynthesisInitialized) {
                initializeSpeechSynthesis();
            }
        }, { once: true });
        
        // Function to create an audio URL from browser speech synthesis
        // This is a fallback method that works even when the direct speech synthesis fails
        async function createAndCacheBrowserSpeechAudio(text, language) {
            return new Promise((resolve, reject) => {
                try {
                    log('Creating browser speech audio fallback for: ' + text.substring(0, 20) + (text.length > 20 ? '...' : ''));
                    
                    // First try using a simpler approach for all browsers
                    // This doesn't actually create an audio file, but provides a URL that will trigger speech
                    try {
                        // Create a data URL that contains a minimal HTML page with script to speak the text
                        const encodedText = encodeURIComponent(text);
                        const encodedLang = encodeURIComponent(language);
                        
                        // Create a data URI with HTML that will speak the text when loaded
                        // Use a single-line data URL to avoid template literal issues
                        const dataUrl = `data:text/html;charset=utf-8,<!DOCTYPE html><html><body><script>window.onload=function(){try{if('speechSynthesis' in window){const u=new SpeechSynthesisUtterance(decodeURIComponent("${encodedText}"));u.lang=decodeURIComponent("${encodedLang}");window.speechSynthesis.speak(u);}}catch(e){console.error("Speech error:",e);}}</script></body></html>`;
                        
                        // Cache this URL
                        audioCache.lastTranslation.audios['browser_simple_fallback'] = {
                            url: dataUrl,
                            text: text,
                            language: language,
                            type: 'browser_iframe'
                        };
                        
                        log('✅ Created simple browser speech fallback');
                        
                        // Try the more advanced method if available
                        if (window.MediaRecorder && (window.AudioContext || window.webkitAudioContext)) {
                            advancedBrowserSpeechFallback(text, language)
                                .then(url => {
                                    log('✅ Advanced browser speech fallback created successfully');
                                    resolve(url);
                                })
                                .catch(err => {
                                    log('⚠️ Advanced browser speech fallback failed, using simple fallback: ' + err.message);
                                    resolve(dataUrl);
                                });
                        } else {
                            // If MediaRecorder is not available, just use the simple method
                            log('⚠️ MediaRecorder not available, using simple fallback');
                            resolve(dataUrl);
                        }
                    } catch (simpleError) {
                        log('❌ Error creating simple fallback: ' + simpleError.message);
                        reject(simpleError);
                    }
                } catch (error) {
                    log('❌ Error in createAndCacheBrowserSpeechAudio: ' + error.message);
                    reject(error);
                }
            });
        }
        
        // Advanced fallback method using MediaRecorder
        function advancedBrowserSpeechFallback(text, language) {
            return new Promise((resolve, reject) => {
                try {
                    // Create an audio context
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContext) {
                        reject(new Error('AudioContext not supported'));
                        return;
                    }
                    
                    // Use MediaRecorder API to record the audio
                    // First set up an audio context and destination node
                    const audioContext = new AudioContext();
                    const destination = audioContext.createMediaStreamDestination();
                    const mediaRecorder = new MediaRecorder(destination.stream);
                    
                    // Create an utterance 
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = language;
                    
                    // We'll store the audio chunks here
                    const audioChunks = [];
                    
                    // Set up event listeners for recording
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    // When recording stops, create a blob and URL
                    mediaRecorder.onstop = () => {
                        try {
                            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                            const audioUrl = URL.createObjectURL(audioBlob);
                            
                            // Cache the audio
                            audioCache.lastTranslation.audios['browser_advanced_fallback'] = {
                                url: audioUrl,
                                blob: audioBlob,
                                text: text,
                                language: language,
                                type: 'browser_audio_element'
                            };
                            
                            resolve(audioUrl);
                        } catch (blobError) {
                            reject(blobError);
                        }
                    };
                    
                    // Start recording
                    mediaRecorder.start();
                    
                    // Play the speech but send it to the destination node
                    window.speechSynthesis.cancel();
                    window.speechSynthesis.speak(utterance);
                    
                    // Stop recording after a reasonable time
                    // Calculate a good duration based on text length (rough estimate)
                    const durationMs = Math.min(10000, Math.max(2000, text.length * 100));
                    setTimeout(() => {
                        if (mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                        }
                    }, durationMs);
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        function connectWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                
                log(`Connecting to WebSocket at ${wsUrl}`);
                socket = new WebSocket(wsUrl);
                
                socket.onopen = function() {
                    log('WebSocket connection established');
                    isConnected = true;
                    updateConnectionUI(true);
                    showSuccess('Connected to classroom');
                    
                    // Register as student with selected language
                    registerAsStudent(selectedLanguage);
                };
                
                socket.onclose = function() {
                    log('WebSocket connection closed');
                    isConnected = false;
                    updateConnectionUI(false);
                };
                
                socket.onerror = function(error) {
                    log('WebSocket error: ' + JSON.stringify(error));
                    showError('Connection error. Please try again.');
                    isConnected = false;
                    updateConnectionUI(false);
                };
                
                socket.onmessage = function(event) {
                    const message = JSON.parse(event.data);
                    log('Received message: ' + JSON.stringify(message).substring(0, 200) + 
                        (JSON.stringify(message).length > 200 ? '... (truncated)' : ''));
                    
                    // Handle connection message with session ID
                    if (message.type === 'connection' && message.sessionId) {
                        sessionId = message.sessionId;
                        log(`Session ID: ${sessionId}`);
                    }
                    
                    // Handle translation message
                    if (message.type === 'translation') {
                        // Check if this is audio data from a server TTS service
                        const hasAudioData = message.audioData && message.audioData.length > 0;
                        const useClientSpeech = message.useClientSpeech === true;
                        const ttsServiceType = message.ttsServiceType || 'browser';
                        
                        log(`Received translation with TTS service: ${ttsServiceType}, hasAudio: ${hasAudioData}, useClientSpeech: ${useClientSpeech}`);
                        
                        // For browser TTS, ensure useClientSpeech is always set
                        if (ttsServiceType === 'browser' && !useClientSpeech) {
                            log('Setting useClientSpeech=true for browser TTS service');
                            useClientSpeech = true;
                        }
                        
                        // Update the displayed TTS service type (teacher's preference)
                        document.getElementById('current-tts-service').textContent = getTtsServiceName(ttsServiceType);
                        
                        // Store this translation data for audio comparison
                        window.lastTranslationData = {
                            text: message.text,
                            languageCode: message.targetLanguage,
                            ttsService: ttsServiceType,
                            originalText: message.originalText
                        };
                        
                        // If audio data is included, cache it
                        if (hasAudioData) {
                            const cacheKey = `${message.text}_${message.targetLanguage}_${ttsServiceType}`;
                            window.audioCache[cacheKey] = message.audioData;
                            log(`Cached audio for "${message.text.substring(0, 20)}..." with service ${ttsServiceType}`);
                        }
                        
                        // Display the translation text and handle audio depending on the service type
                        displayTranslation(
                            message.text, 
                            message.sourceLanguage, 
                            message.targetLanguage, 
                            message.originalText,
                            hasAudioData ? message.audioData : null,
                            useClientSpeech,
                            ttsServiceType
                        );
                    }
                    
                    // Handle TTS service audio response
                    if (message.type === 'tts_response') {
                        const ttsService = message.ttsService || 'openai';
                        const audioData = message.audioData;
                        
                        log(`Received TTS audio response from ${ttsService} service`);
                        
                        // Calculate latency from request time if available
                        if (window.ttsRequestTimes && window.ttsRequestTimes[ttsService]) {
                            const endTime = performance.now();
                            const startTime = window.ttsRequestTimes[ttsService];
                            const latency = Math.round(endTime - startTime);
                            
                            log(`${ttsService} TTS service latency: ${latency}ms`);
                            
                            // Record metrics if audio data exists
                            if (audioData && audioData.length > 0) {
                                // Calculate size in KB (base64 is 4/3 the size of binary)
                                const sizeInKB = (audioData.length * 3/4) / 1024;
                                
                                // Record metrics
                                TTSServiceManager.recordMetrics(ttsService, latency, sizeInKB);
                            }
                            
                            // Clear request time
                            delete window.ttsRequestTimes[ttsService];
                        }
                        
                        if (audioData && audioData.length > 0) {
                            try {
                                // Convert base64 to blob for playback
                                const binaryString = atob(audioData);
                                const bytes = new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    bytes[i] = binaryString.charCodeAt(i);
                                }
                                
                                // Create blob and URL
                                const blob = new Blob([bytes.buffer], { type: 'audio/mp3' }); 
                                const audioURL = URL.createObjectURL(blob);
                                
                                // Cache the audio data
                                audioCache.lastTranslation.audios[ttsService] = {
                                    data: audioData,
                                    url: audioURL,
                                    blob: blob,
                                    type: 'server',
                                    size: blob.size / 1024 // Size in KB
                                };
                                
                                // Play the audio
                                const audioPlayer = document.getElementById('audio-player');
                                audioPlayer.src = audioURL;
                                audioPlayer.play();
                                
                                // Show in comparison section
                                // Audio comparison section removed
                                
                                showSuccess(`Playing with ${getTtsServiceName(ttsService)}`);
                            } catch (error) {
                                log(`Error processing ${ttsService} audio: ${error.message}`);
                                showError(`Failed to process ${getTtsServiceName(ttsService)} audio`);
                            }
                        } else {
                            log(`No audio data received from ${ttsService} service`);
                            showError(`No audio received from ${getTtsServiceName(ttsService)}`);
                        }
                    }
                    
                    // Add message to UI
                    addMessageToUI(message);
                };
            } catch (error) {
                log('Error creating WebSocket: ' + error.message);
                showError('Failed to establish connection: ' + error.message);
            }
        }
        
        function disconnectWebSocket() {
            if (socket) {
                log('Disconnecting WebSocket');
                socket.close();
            }
        }
        
        function registerAsStudent(languageCode) {
            if (!isConnected) {
                log('Cannot register, WebSocket not connected');
                showError('Not connected to classroom');
                return;
            }
            
            const message = {
                type: 'register',
                role: 'student',
                languageCode: languageCode
                // No TTS service settings - controlled by teacher
            };
            
            log(`Registering as student with language ${languageCode}`);
            socket.send(JSON.stringify(message));
            showSuccess(`Receiving translations in ${getLanguageName(languageCode)}`);
            
            // Update UI to show active language
            updateActiveLanguage(languageCode);
        }
        
        // Get a user-friendly name for the TTS service
        function getTtsServiceName(serviceType) {
            const serviceNames = {
                'browser': 'Browser Speech',
                'openai': 'OpenAI TTS (Emotions)',
                'silent': 'Silent Mode'
            };
            
            return serviceNames[serviceType] || serviceType;
        }
        
        // Convert a display name back to a service type
        function getTtsServiceTypeFromName(displayName) {
            let serviceType = 'browser'; // Default fallback
            if (displayName.includes('OpenAI')) {
                serviceType = 'openai';
            } else if (displayName.includes('Silent')) {
                serviceType = 'silent';
            }
            return serviceType;
        }
        
        function updateConnectionUI(connected) {
            const connectBtn = document.getElementById('connect-btn');
            const disconnectBtn = document.getElementById('disconnect-btn');
            const indicator = document.getElementById('connection-indicator');
            const status = document.getElementById('connection-status');
            
            if (connected) {
                indicator.className = 'indicator connected';
                status.textContent = 'Connected to Classroom';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
            } else {
                indicator.className = 'indicator disconnected';
                status.textContent = 'Disconnected';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
            }
        }
        
        function displayTranslation(text, sourceLanguage, targetLanguage, originalText, audioData = null, useClientSpeech = false, ttsServiceType = 'browser') {
            const translationBox = document.getElementById('translation-box');
            const audio = document.getElementById('audio-player');
            const playButton = document.getElementById('play-button');
            // Audio comparison section removed
            
            // CRITICAL FIX: Ensure that useClientSpeech is ALWAYS true when ttsServiceType is 'browser'
            // This is the key fix for the browser TTS issue
            if (ttsServiceType === 'browser') {
                useClientSpeech = true;
                log('🔧 FIX: Forcing useClientSpeech=true for browser TTS service');
            }
            
            // Update the cache with this new translation
            audioCache.lastTranslation.text = text;
            audioCache.lastTranslation.originalText = originalText || "";
            audioCache.lastTranslation.targetLanguage = targetLanguage;
            
            // Create HTML with both original and translated text
            let html = '';
            if (originalText) {
                html += `<p style="color: #777; font-size: 0.9em; margin-bottom: 5px;">Original: "${originalText}"</p>`;
            }
            html += `<p style="font-size: 1.2em; font-weight: bold;">${text}</p>`;
            
            // Add a label showing which TTS service is being used
            html += `<p style="color: #666; font-size: 0.8em; text-align: right; margin-top: 5px;">
                        Audio: ${getTtsServiceName(ttsServiceType)}
                     </p>`;
            
            translationBox.innerHTML = html;
            
            // Highlight the translation
            translationBox.style.animation = 'none';
            setTimeout(() => {
                translationBox.style.animation = 'highlight 1s';
            }, 10);
            
            // Add CSS for the highlight animation if it doesn't exist
            if (!document.getElementById('highlight-animation')) {
                const style = document.createElement('style');
                style.id = 'highlight-animation';
                style.textContent = `
                    @keyframes highlight {
                        0% { background-color: #e3f2fd; }
                        100% { background-color: #f9f9f9; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Handle audio based on the TTS service type
            if (ttsServiceType === 'silent') {
                // Silent mode - disable audio playback
                playButton.disabled = true;
                playButton.innerHTML = '<span class="play-icon">🔇</span> Audio Disabled';
                log('Silent mode active, no audio playback');
                
                // Store in cache that this service is silent
                audioCache.lastTranslation.audios[ttsServiceType] = { 
                    isSilent: true
                };
            } else if (audioData && audioData.length > 0) {
                // We have server-generated audio data (base64 encoded)
                try {
                    log('Received server-generated audio data, preparing for playback');
                    
                    // Log audio data details before processing
                    log(`Processing audio data: length=${audioData.length} chars, first 50 chars: ${audioData.substring(0, 50)}...`);
                    
                    // Make sure the audioData is actually a base64 string
                    // Sometimes it might be sent with a data URL prefix, so we need to remove it
                    let cleanBase64 = audioData;
                    if (audioData.startsWith('data:')) {
                        // Extract the base64 part from the data URL
                        const commaIndex = audioData.indexOf(',');
                        if (commaIndex !== -1) {
                            cleanBase64 = audioData.substring(commaIndex + 1);
                            log('Extracted base64 data from data URL');
                        }
                    }
                    
                    // Variables to store the processed binary data
                    let bytes = null;
                    let headerHex = '';
                    
                    try {
                        // Convert base64 to a blob
                        const binaryString = atob(cleanBase64);
                        log(`Converted binary string length: ${binaryString.length} bytes`);
                        
                        bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        
                        // Check header bytes to determine format (MP3 starts with ID3 or 0xFF 0xFB)
                        headerHex = Array.from(bytes.slice(0, 4))
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join(' ');
                        log(`Audio data header: ${headerHex}`);
                    } catch (error) {
                        log(`WARNING: Failed to decode base64 data: ${error.message}`);
                        throw new Error(`Failed to decode audio data: ${error.message}`);
                    }
                    
                    // Make sure we got valid binary data
                    if (!bytes || bytes.length === 0) {
                        throw new Error('Failed to create valid binary data from base64');
                    }
                    
                    // Determine MIME type based on header
                    let mimeType = 'audio/mp3'; // Default assumption
                    if (headerHex.startsWith('49 44 33')) { // ID3
                        mimeType = 'audio/mp3';
                        log('Detected MP3 audio with ID3 tag');
                    } else if (headerHex.startsWith('ff fb')) {
                        mimeType = 'audio/mp3';
                        log('Detected MP3 audio without ID3 tag');
                    } else if (headerHex.startsWith('52 49 46 46')) { // RIFF
                        mimeType = 'audio/wav';
                        log('Detected WAV audio');
                    } else {
                        log(`Unknown audio format with header: ${headerHex}`);
                    }
                    
                    // Create blob with detected MIME type
                    const blob = new Blob([bytes.buffer], { type: mimeType });
                    log(`Created audio blob: size=${blob.size} bytes, type=${mimeType}`);
                    
                    const audioURL = URL.createObjectURL(blob);
                    
                    // Cache the audio data
                    audioCache.lastTranslation.audios[ttsServiceType] = {
                        data: audioData,
                        url: audioURL,
                        blob: blob,
                        type: 'server'
                    };
                    
                    // Set up audio element and play button
                    audio.src = audioURL;
                    playButton.disabled = false;
                    
                    // Update button to show which TTS service is being used
                    playButton.innerHTML = `<span class="play-icon">▶</span> Play Translation (${getTtsServiceName(ttsServiceType)})`;
                    
                    // Define handler for audio playback
                    const playAudio = () => {
                        log(`Playing server-generated audio (${ttsServiceType} TTS)`);
                        audio.play().catch(err => {
                            log('Error playing audio: ' + err.message);
                            showError('Audio playback failed: ' + err.message);
                        });
                        
                        // Visual feedback during playback
                        playButton.style.backgroundColor = '#e74c3c';
                        playButton.innerHTML = '<span class="play-icon">🔊</span> Playing...';
                    };
                    
                    // Set up click handler for play button
                    // Store a reference to the current TTS service type so it remains consistent
                    playButton.onclick = playAudio;
                    
                    // Reset button when audio ends - preserve the TTS service information
                    audio.onended = () => {
                        playButton.style.backgroundColor = '';
                        playButton.innerHTML = `<span class="play-icon">▶</span> Play Translation (${getTtsServiceName(ttsServiceType)})`;
                    };
                    
                    // Auto-play for OpenAI TTS when that service is selected
                    if (ttsServiceType === 'openai') {
                        log('Auto-playing OpenAI TTS audio');
                        // Slight delay to make sure audio is loaded
                        setTimeout(playAudio, 300);
                        showSuccess('Playing OpenAI translation audio');
                    } else {
                        showSuccess('Server-generated audio ready to play');
                    }
                    
                    // Audio comparison section removed
                } catch (error) {
                    log('Error processing audio data: ' + error.message);
                    // Fall back to browser speech synthesis
                    generateSpeechFromText(text, targetLanguage);
                }
            } else if (useClientSpeech) {
                // Explicitly instructed to use client speech synthesis
                log('Server explicitly requested client-side speech synthesis');
                
                // Browser speech synthesis should always auto-play for student interface
                log('Auto-playing browser speech synthesis for translation');
                
                // Create and play speech immediately using Web Speech API
                if ('speechSynthesis' in window) {
                    // In some browsers, speech synthesis won't work unless it's triggered by user interaction
                    // We'll still try to auto-play, but also set up the play button for manual playback
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    // Set language code, mapping short codes to full BCP 47 language tags if needed
                    const langCodeMap = {
                        'es': 'es-ES',
                        'fr': 'fr-FR',
                        'de': 'de-DE',
                        'it': 'it-IT',
                        'zh': 'zh-CN',
                        'ja': 'ja-JP',
                        'ru': 'ru-RU',
                        'ar': 'ar-SA',
                        'pt': 'pt-BR',
                        'ko': 'ko-KR',
                        'en': 'en-US'
                    };
                    
                    // Map short language code to full code, or use as is if already in right format
                    utterance.lang = langCodeMap[targetLanguage] || targetLanguage;
                    log(`Auto-playing speech in language ${utterance.lang}`);
                    
                    // Apply speech parameters if available
                    if (message.speechParams && message.speechParams.speed) {
                        utterance.rate = message.speechParams.speed;
                    }
                    
                    // Automatically play the speech
                    window.speechSynthesis.cancel(); // Cancel any ongoing speech
                    
                    // Add event listeners to better debug speech synthesis issues
                    utterance.onstart = () => log('Speech synthesis started');
                    utterance.onend = () => log('Speech synthesis completed');
                    utterance.onerror = (e) => log('Speech synthesis error: ' + e.error);
                    
                    // Try auto-playing
                    window.speechSynthesis.speak(utterance);
                    showSuccess('Auto-playing translation with Browser TTS');
                    
                    // Also set up the play button for manual playback
                    playButton.disabled = false;
                    playButton.innerHTML = '<span class="play-icon">▶</span> Play Speech Again';
                    playButton.onclick = () => {
                        window.speechSynthesis.cancel();
                        window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));
                    };
                } else {
                    // Fall back to normal generation if Speech API is not available
                    log('Speech API not available for auto-play, falling back to normal behavior');
                    generateSpeechFromText(text, targetLanguage, ttsServiceType);
                }
            } else if (ttsServiceType === 'openai' && !audioData) {
                // We're supposed to use OpenAI TTS but didn't receive audio data - request it from server
                log('OpenAI TTS selected but no audio data received - trying to request it from server');
                TTSServiceManager.requestServerTTS(text, targetLanguage, 'openai', performance.now());
            } else {
                // We don't have audio data and no explicit instruction to use client speech
                if (ttsServiceType === 'browser') {
                    // For browser TTS service, use the browser speech synthesis
                    log('🔊 BROWSER TTS: Using enhanced browser speech synthesis');
                    
                    // First try to initialize the speech synthesis API if it hasn't been initialized yet
                    if (!speechSynthesisInitialized) {
                        initializeSpeechSynthesis();
                    }
                    
                    // Check if we've been granted audio permission
                    const hasPermission = window.browserTTSPermissionGranted === true;
                    log(`🔊 BROWSER TTS: Audio permission status: ${hasPermission ? 'Granted ✓' : 'Not yet granted ✗'}`);
                    
                    // If we don't have permission yet, show a notice
                    if (!hasPermission) {
                        showError('Please click anywhere on the page to enable audio playback');
                        // Make sure the permission banner is visible
                        const banner = document.getElementById('permission-banner');
                        if (banner) banner.style.display = 'block';
                    }
                    
                    // Create a flag to track if the direct speech synthesis approach works
                    let directSpeechFailed = false;
                    
                    // Create and play speech immediately using Web Speech API
                    if ('speechSynthesis' in window) {
                        log('✅ Browser support check: speechSynthesis API is available');
                        
                        try {
                            // Create a new utterance with the translated text
                            const utterance = new SpeechSynthesisUtterance(text);
                            
                            // Set language code, mapping short codes to full BCP 47 language tags if needed
                            const langCodeMap = {
                                'es': 'es-ES',
                                'fr': 'fr-FR',
                                'de': 'de-DE',
                                'it': 'it-IT',
                                'zh': 'zh-CN',
                                'ja': 'ja-JP',
                                'ru': 'ru-RU',
                                'ar': 'ar-SA',
                                'pt': 'pt-BR',
                                'ko': 'ko-KR',
                                'en': 'en-US'
                            };
                            
                            // Map short language code to full code, or use as is if already in right format
                            utterance.lang = langCodeMap[targetLanguage] || targetLanguage;
                            log(`🔤 Language set to: ${utterance.lang}`);
                            
                            // IMPORTANT: Store the audio conversion for later playback using audio element
                            // This is a fallback in case the direct speech synthesis doesn't work
                            createAndCacheBrowserSpeechAudio(text, utterance.lang).then(audioUrl => {
                                if (directSpeechFailed) {
                                    log('🔄 Using audio element fallback for browser speech synthesis');
                                    
                                    // Check if this is a data URL (the simple fallback)
                                    if (audioUrl.startsWith('data:text/html')) {
                                        // Create a hidden iframe to play the speech
                                        const speechFrame = document.createElement('iframe');
                                        speechFrame.style.display = 'none';
                                        speechFrame.src = audioUrl;
                                        document.body.appendChild(speechFrame);
                                        
                                        // Remove the iframe after a reasonable time
                                        setTimeout(() => {
                                            try {
                                                document.body.removeChild(speechFrame);
                                            } catch (e) {
                                                // Ignore errors
                                            }
                                        }, 10000);
                                        
                                        log('🔄 Using iframe fallback for speech synthesis');
                                    } else {
                                        // Use regular audio element for advanced fallback
                                        const audioPlayer = document.getElementById('audio-player');
                                        audioPlayer.src = audioUrl;
                                        audioPlayer.play().catch(error => {
                                            log('🔄 Audio element fallback also failed: ' + error.message);
                                        });
                                    }
                                }
                            });
                            
                            // Add event listeners for detailed debugging
                            utterance.onstart = () => {
                                log('🎙️ BROWSER TTS: Speech synthesis STARTED');
                                // Update UI to show speaking state
                                playButton.style.backgroundColor = '#e74c3c';
                                playButton.innerHTML = '<span class="play-icon">🔊</span> Speaking...';
                            };
                            
                            utterance.onend = () => {
                                log('✅ BROWSER TTS: Speech synthesis COMPLETED');
                                // Reset UI
                                playButton.style.backgroundColor = '';
                                playButton.innerHTML = '<span class="play-icon">▶</span> Play Again';
                            };
                            
                            utterance.onerror = (e) => {
                                log(`❌ BROWSER TTS ERROR: ${e.error || 'Unknown error'}`);
                                directSpeechFailed = true;
                                playButton.style.backgroundColor = '';
                                playButton.innerHTML = '<span class="play-icon">▶</span> Try Again';
                            };
                            
                            // Make sure any speech is canceled
                            window.speechSynthesis.cancel();
                            
                            // Force resume the synthesis (workaround for Chrome issue)
                            window.speechSynthesis.resume();
                            
                            // Play the speech
                            log('▶️ BROWSER TTS: Speaking now...');
                            window.speechSynthesis.speak(utterance);
                            
                            // Show success message
                            showSuccess('Auto-playing translation with Browser TTS');
                            
                            // Store in cache that we used browser speech
                            audioCache.lastTranslation.audios['browser'] = {
                                text: text,
                                language: utterance.lang,
                                type: 'browser'
                            };
                            
                            // Set a timeout to check if speech started
                            setTimeout(() => {
                                // If speech synthesis is paused, force resume it
                                if (window.speechSynthesis && window.speechSynthesis.paused) {
                                    window.speechSynthesis.resume();
                                    log('🔄 Detected paused speech synthesis, resuming it');
                                }
                            }, 500);
                        } catch (speechError) {
                            log(`❌ FATAL ERROR initializing speech: ${speechError.message}`);
                            showError(`Failed to initialize speech: ${speechError.message}`);
                            directSpeechFailed = true;
                        }
                        
                        // Also set up manual play button
                        playButton.disabled = false;
                        playButton.innerHTML = '<span class="play-icon">▶</span> Play Speech Again';
                        playButton.onclick = () => {
                            window.speechSynthesis.cancel();
                            window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));
                        };
                    } else {
                        // If Web Speech API is not available
                        generateSpeechFromText(text, targetLanguage, ttsServiceType);
                    }
                } else if (ttsServiceType === 'openai') {
                    // For OpenAI TTS service with no audio, try to request from server first
                    log('OpenAI TTS service selected but no audio available - requesting from server');
                    
                    // Set up a fallback just in case
                    playButton.disabled = false;
                    playButton.innerHTML = '<span class="play-icon">▶</span> Play Translation (OpenAI)';
                    
                    // When clicked, try to get OpenAI audio first
                    playButton.onclick = () => {
                        log('Requesting OpenAI TTS audio from server for play button');
                        TTSServiceManager.requestServerTTS(text, targetLanguage, 'openai', performance.now());
                    };
                    
                    // Also try to request it immediately
                    TTSServiceManager.requestServerTTS(text, targetLanguage, 'openai', performance.now());
                } else {
                    // For any other TTS service, provide a consistent fallback
                    log('No audio data available for ' + ttsServiceType + ' service, using consistent fallback');
                    generateSpeechFromText(text, targetLanguage, ttsServiceType);
                }
            }
        }
        
        // Function to update audio comparison UI
        function updateAudioComparison() {
            const comparisonOptions = document.getElementById('comparison-options');
            comparisonOptions.innerHTML = '';
            
            // Get available TTS services with audio for the current translation
            const audioServices = Object.keys(audioCache.lastTranslation.audios);
            
            if (audioServices.length === 0) {
                comparisonOptions.innerHTML = '<p>No audio available for comparison yet.</p>';
                return;
            }
            
            // Create a player for each available TTS service
            audioServices.forEach(service => {
                const audioInfo = audioCache.lastTranslation.audios[service];
                
                // Skip if this is silent mode
                if (audioInfo.isSilent) {
                    return;
                }
                
                const serviceCard = document.createElement('div');
                serviceCard.className = 'service-comparison-card';
                serviceCard.style.padding = '15px';
                serviceCard.style.backgroundColor = '#f5f8fa';
                serviceCard.style.borderRadius = '8px';
                serviceCard.style.border = '1px solid #e1e4e8';
                
                // Create audio element 
                const audioElement = document.createElement('audio');
                audioElement.style.width = '100%';
                audioElement.controls = true;
                
                if (audioInfo.url) {
                    audioElement.src = audioInfo.url;
                }
                
                // Create service info
                const serviceInfo = document.createElement('div');
                serviceInfo.style.display = 'flex';
                serviceInfo.style.justifyContent = 'space-between';
                serviceInfo.style.alignItems = 'center';
                serviceInfo.style.marginBottom = '10px';
                
                const serviceName = document.createElement('h4');
                serviceName.style.margin = '0';
                serviceName.textContent = getTtsServiceName(service);
                
                const serviceBadge = document.createElement('span');
                serviceBadge.style.backgroundColor = service === 'openai' ? '#6366f1' : '#3498db';
                serviceBadge.style.color = 'white';
                serviceBadge.style.padding = '3px 8px';
                serviceBadge.style.borderRadius = '12px';
                serviceBadge.style.fontSize = '12px';
                serviceBadge.textContent = service === 'openai' ? 'Emotional' : 'Standard';
                
                serviceInfo.appendChild(serviceName);
                serviceInfo.appendChild(serviceBadge);
                
                // Add elements to card
                serviceCard.appendChild(serviceInfo);
                serviceCard.appendChild(audioElement);
                
                // Add card to options
                comparisonOptions.appendChild(serviceCard);
            });
        }
        
        // Play with a specific TTS service
        async function playWithTTSService(ttsService) {
            const translationText = audioCache.lastTranslation.text;
            const targetLanguage = audioCache.lastTranslation.targetLanguage;
            
            if (!translationText || !targetLanguage) {
                showError('No translation available to play');
                return;
            }
            
            log(`Playing translation with ${getTtsServiceName(ttsService)} service`);
            
            if (ttsService === 'silent') {
                showSuccess('Silent mode - no audio played');
                return;
            }
            
            // If we already have this audio cached, use it
            if (audioCache.lastTranslation.audios[ttsService]) {
                const cachedAudio = audioCache.lastTranslation.audios[ttsService];
                
                if (cachedAudio.url) {
                    const audioPlayer = document.getElementById('audio-player');
                    audioPlayer.src = cachedAudio.url;
                    audioPlayer.play();
                    showSuccess(`Playing with ${getTtsServiceName(ttsService)}`);
                    return;
                }
            }
            
            // For browser TTS, use speech synthesis
            if (ttsService === 'browser') {
                if ('speechSynthesis' in window) {
                    // Create the utterance
                    const utterance = new SpeechSynthesisUtterance(translationText);
                    
                    // Set language code, mapping short codes to full BCP 47 language tags if needed
                    const langCodeMap = {
                        'es': 'es-ES',
                        'fr': 'fr-FR',
                        'de': 'de-DE',
                        'it': 'it-IT',
                        'zh': 'zh-CN',
                        'ja': 'ja-JP',
                        'ru': 'ru-RU',
                        'ar': 'ar-SA',
                        'pt': 'pt-BR',
                        'ko': 'ko-KR',
                        'en': 'en-US'
                    };
                    
                    // Map short language code to full code, or use as is if already in right format
                    utterance.lang = langCodeMap[targetLanguage] || targetLanguage;
                    
                    // Speak the text
                    speechSynthesis.speak(utterance);
                    
                    // Cache this for later comparison (empty data/url as we can't capture it)
                    audioCache.lastTranslation.audios['browser'] = {
                        type: 'browser',
                        data: null,
                        url: null
                    };
                    
                    showSuccess('Playing with Browser TTS');
                } else {
                    showError('Browser does not support speech synthesis');
                }
                return;
            }
            
            // For OpenAI or other server-based TTS, re-register with that service
            if (isConnected) {
                // Send a request to get audio for the current translation but with a different TTS service
                const message = {
                    type: 'tts_request',
                    text: translationText,
                    languageCode: targetLanguage,
                    ttsService: ttsService,
                    originalText: audioCache.lastTranslation.originalText || ""
                };
                
                socket.send(JSON.stringify(message));
                showSuccess(`Requesting audio with ${getTtsServiceName(ttsService)}...`);
            } else {
                showError('Cannot use server TTS services while disconnected');
            }
        }
        
        // Generate speech from text using browser's Speech Synthesis API (Web Speech API)
        function generateSpeechFromText(text, languageCode, ttsServiceType = 'browser') {
            const audio = document.getElementById('audio-player');
            const playButton = document.getElementById('play-button');
            
            // Log the TTS service type being used
            log(`Generating speech with service type: ${ttsServiceType}`);
            
            // If OpenAI TTS was selected but we're still using browser speech,
            // this means there was an issue with the server-generated audio
            if (ttsServiceType === 'openai') {
                log('WARNING: Fallback to browser speech despite OpenAI TTS selection');
                showWarning('Using browser speech as fallback (server audio unavailable)');
            }
            
            // Disable button during processing
            playButton.disabled = true;
            
            try {
                // Check if the browser supports speech synthesis
                if ('speechSynthesis' in window) {
                    log('Web Speech API available, generating audio...');
                    
                    // Create the utterance
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    // Set language code, mapping short codes to full BCP 47 language tags if needed
                    const langCodeMap = {
                        'es': 'es-ES',
                        'fr': 'fr-FR',
                        'de': 'de-DE',
                        'it': 'it-IT',
                        'zh': 'zh-CN',
                        'ja': 'ja-JP',
                        'ru': 'ru-RU',
                        'ar': 'ar-SA',
                        'pt': 'pt-BR',
                        'ko': 'ko-KR',
                        'en': 'en-US'
                    };
                    
                    // Map short language code to full code, or use as is if already in right format
                    utterance.lang = langCodeMap[languageCode] || languageCode;
                    
                    // Store audio as blob using MediaRecorder
                    let chunks = [];
                    
                    // Create audio context and media stream destination
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const destination = audioContext.createMediaStreamDestination();
                    
                    // Create oscillator and gain (to capture speech synthesis)
                    // This is a workaround since we can't directly capture SpeechSynthesis output
                    const oscillator = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    oscillator.connect(gain);
                    gain.connect(destination);
                    
                    // Setup MediaRecorder to capture the audio
                    const mediaRecorder = new MediaRecorder(destination.stream);
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            chunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        // Create a blob from all the chunks
                        const blob = new Blob(chunks, { type: 'audio/wav' });
                        const audioURL = URL.createObjectURL(blob);
                        
                        // Set the audio source and make play button visible
                        audio.src = audioURL;
                        playButton.disabled = false;
                        
                        log('Audio generation completed, ready for playback');
                    };
                    
                    // Force using speech synthesis directly instead for now
                    // The MediaRecorder approach works in theory but is complex and unreliable across browsers

                    // Create a simpler approach: we'll return immediately with a playable button,
                    // and the button will trigger speech synthesis on demand
                    playButton.disabled = false;
                    playButton.onclick = () => {
                        log(`Playing translation audio in ${utterance.lang}`);
                        window.speechSynthesis.cancel(); // Cancel any ongoing speech
                        window.speechSynthesis.speak(utterance);
                        
                        // Visual feedback during playback
                        playButton.style.backgroundColor = '#e74c3c';
                        playButton.innerHTML = '<span class="play-icon">🔊</span> Playing...';
                        
                        // Reset button when done
                        utterance.onend = () => {
                            playButton.style.backgroundColor = '';
                            playButton.innerHTML = '<span class="play-icon">▶</span> Play Translation';
                        };
                    };
                    
                    log(`Audio ready for playback in language: ${utterance.lang}`);
                    showSuccess('Translation audio ready to play');
                } else {
                    // No speech synthesis support
                    log('Speech synthesis not supported in this browser');
                    showError('Audio playback not supported in your browser');
                    playButton.disabled = true;
                }
            } catch (error) {
                log('Error generating speech: ' + error.message);
                showError('Failed to generate speech audio');
                playButton.disabled = true;
            }
        }
        
        /**
         * TTS Service Manager
         * 
         * Refactored to follow separation of concerns and improve maintainability.
         * This class handles all TTS service related operations.
         */
        class TTSServiceManager {
            // Store metrics for TTS services
            static metrics = {
                browser: {
                    latency: [],
                    fileSize: []
                },
                openai: {
                    latency: [],
                    fileSize: []
                }
            };
            
            /**
             * Play audio with a specific TTS service
             * 
             * @param {string} ttsService - The TTS service to use (browser, openai, silent)
             */
            static playWithService(ttsService) {
                // Validate required data
                if (!this.validateTranslationData()) {
                    return;
                }
                
                const text = window.lastTranslationData.text;
                const languageCode = window.lastTranslationData.languageCode;
                
                log(`Requesting TTS service ${ttsService} to play: "${text.substring(0, 20)}..."`);
                
                // Check cache first
                if (this.checkAndUseCache(text, languageCode, ttsService)) {
                    return;
                }
                
                // Start latency measurement
                const startTime = performance.now();
                
                // Handle different service types
                switch (ttsService) {
                    case 'silent':
                        this.handleSilentMode();
                        break;
                    case 'browser':
                        this.useBrowserSpeechSynthesis(text, languageCode, startTime);
                        break;
                    default:
                        this.requestServerTTS(text, languageCode, ttsService, startTime);
                        break;
                }
            }
            
            /**
             * Validate that we have translation data to use
             * 
             * @returns {boolean} True if valid data exists
             */
            static validateTranslationData() {
                if (!window.lastTranslationData || !window.lastTranslationData.text) {
                    showError('No translation available to play');
                    return false;
                }
                return true;
            }
            
            /**
             * Check if audio is in cache and use it if available
             * 
             * @param {string} text - The text to play
             * @param {string} languageCode - The language code
             * @param {string} ttsService - The TTS service
             * @returns {boolean} True if cache was used
             */
            static checkAndUseCache(text, languageCode, ttsService) {
                const cacheKey = `${text}_${languageCode}_${ttsService}`;
                if (window.audioCache[cacheKey]) {
                    log(`Using cached audio for service ${ttsService}`);
                    AudioPlayer.playFromBase64(window.audioCache[cacheKey]);
                    return true;
                }
                return false;
            }
            
            /**
             * Handle silent mode (no audio)
             */
            static handleSilentMode() {
                showSuccess('Silent mode - no audio played');
            }
            
            /**
             * Use browser's built-in speech synthesis
             * 
             * @param {string} text - The text to speak
             * @param {string} languageCode - The language code
             * @param {number} startTime - Start time for latency measurement
             */
            static useBrowserSpeechSynthesis(text, languageCode, startTime) {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = languageCode || 'en-US';
                    utterance.rate = 1.0;
                    utterance.pitch = 1.0;
                    
                    // Measure audio size (estimate since browser API doesn't provide size)
                    const estimatedSize = text.length * 0.1; // Rough estimate - 0.1KB per character
                    
                    // Add event listener for when speech starts
                    utterance.onstart = () => {
                        const endTime = performance.now();
                        const latency = Math.round(endTime - startTime);
                        
                        // Record metrics
                        this.recordMetrics('browser', latency, estimatedSize);
                        
                        log(`Browser TTS latency: ${latency}ms, estimated size: ${estimatedSize.toFixed(1)}KB`);
                    };
                    
                    log(`Using browser speech synthesis for language ${languageCode}`);
                    speechSynthesis.speak(utterance);
                    
                    showSuccess('Playing with browser speech synthesis');
                } else {
                    showError('Browser speech synthesis not available');
                }
            }
            
            /**
             * Request TTS from server
             * 
             * @param {string} text - The text to speak
             * @param {string} languageCode - The language code
             * @param {string} ttsService - The TTS service to use
             * @param {number} startTime - Start time for latency measurement
             */
            static requestServerTTS(text, languageCode, ttsService, startTime) {
                if (isConnected) {
                    const ttsRequest = {
                        type: 'tts_request',
                        text: text,
                        languageCode: languageCode,
                        ttsService: ttsService
                    };
                    
                    // Store start time in global object to be retrieved when response arrives
                    window.ttsRequestTimes = window.ttsRequestTimes || {};
                    window.ttsRequestTimes[ttsService] = startTime;
                    
                    socket.send(JSON.stringify(ttsRequest));
                    showSuccess(`Requesting audio from ${getTtsServiceName(ttsService)}...`);
                } else {
                    showError('Connect to classroom first to use this TTS service');
                }
            }
            
            /**
             * Record metrics for a TTS service
             * 
             * @param {string} service - The TTS service (browser, openai)
             * @param {number} latency - Latency in milliseconds
             * @param {number} fileSize - File size in KB
             */
            static recordMetrics(service, latency, fileSize) {
                if (this.metrics[service]) {
                    // Add to metrics arrays (keep last 5 values for average)
                    this.metrics[service].latency.push(latency);
                    if (this.metrics[service].latency.length > 5) {
                        this.metrics[service].latency.shift();
                    }
                    
                    this.metrics[service].fileSize.push(fileSize);
                    if (this.metrics[service].fileSize.length > 5) {
                        this.metrics[service].fileSize.shift();
                    }
                    
                    // Update UI with average values
                    this.updateMetricsUI();
                }
            }
            
            /**
             * Calculate average of array values
             * 
             * @param {Array<number>} arr - Array of numbers
             * @returns {number} Average value
             */
            static calculateAverage(arr) {
                if (!arr || arr.length === 0) return 0;
                const sum = arr.reduce((a, b) => a + b, 0);
                return sum / arr.length;
            }
            
            /**
             * Update metrics UI with current values
             */
            static updateMetricsUI() {
                // Calculate averages
                const browserLatencyAvg = this.calculateAverage(this.metrics.browser.latency);
                const openaiLatencyAvg = this.calculateAverage(this.metrics.openai.latency);
                const browserSizeAvg = this.calculateAverage(this.metrics.browser.fileSize);
                const openaiSizeAvg = this.calculateAverage(this.metrics.openai.fileSize);
                
                // Update UI elements
                document.getElementById('browser-latency').textContent = 
                    browserLatencyAvg > 0 ? `${Math.round(browserLatencyAvg)}ms` : '-';
                
                document.getElementById('openai-latency').textContent = 
                    openaiLatencyAvg > 0 ? `${Math.round(openaiLatencyAvg)}ms` : '-';
                
                document.getElementById('browser-size').textContent = 
                    browserSizeAvg > 0 ? `${browserSizeAvg.toFixed(1)}KB` : '-';
                
                document.getElementById('openai-size').textContent = 
                    openaiSizeAvg > 0 ? `${openaiSizeAvg.toFixed(1)}KB` : '-';
            }
            
            // Audio comparison UI method removed
        }
        
        /**
         * Audio Player Utility Class
         * 
         * Handles all audio playback operations
         */
        class AudioPlayer {
            /**
             * Play audio from base64 encoded data with improved error handling
             * 
             * @param {string} base64Data - Base64 encoded audio data
             * @returns {Promise<boolean>} - Promise that resolves to true if playback started successfully
             */
            static async playFromBase64(base64Data) {
                try {
                    log(`Playing audio from base64, data length: ${base64Data.length} chars`);
                    log(`First 20 chars of base64: ${base64Data.substring(0, 20)}...`);
                    
                    // Convert base64 to blob for playback
                    const binaryString = atob(base64Data);
                    log(`Converted to binary string of length: ${binaryString.length}`);
                    
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    
                    // Check header bytes to determine format
                    const headerHex = Array.from(bytes.slice(0, 4))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join(' ');
                    log(`Audio data header: ${headerHex}`);
                    
                    // Determine MIME type based on header
                    let mimeType = 'audio/mp3'; // Default assumption
                    
                    if (headerHex.startsWith('49 44 33')) { // ID3
                        mimeType = 'audio/mp3';
                        log('Detected MP3 audio with ID3 tag');
                    } else if (headerHex.startsWith('ff fb')) {
                        mimeType = 'audio/mp3';
                        log('Detected MP3 audio without ID3 tag');
                    } else if (headerHex.startsWith('52 49 46 46')) { // RIFF
                        mimeType = 'audio/wav';
                        log('Detected WAV audio');
                    } else {
                        log(`Unknown audio format with header: ${headerHex}`);
                    }
                    
                    // Create blob with detected MIME type
                    const blob = new Blob([bytes.buffer], { type: mimeType });
                    log(`Created audio blob: size=${blob.size} bytes, type=${mimeType}`);
                    
                    const audioURL = URL.createObjectURL(blob);
                    
                    // Get the audio player
                    const audioPlayer = document.getElementById('audio-player');
                    
                    // Set up promise to track audio loading status
                    const loadPromise = new Promise((resolve, reject) => {
                        // Handle successful loading
                        audioPlayer.onloadeddata = () => {
                            log('Audio loaded successfully');
                            resolve(true);
                        };
                        
                        // Handle errors
                        audioPlayer.onerror = (e) => {
                            const errorMessage = `Audio error: ${audioPlayer.error ? audioPlayer.error.code : 'unknown'}`;
                            log(errorMessage);
                            reject(new Error(errorMessage));
                        };
                    });
                    
                    // Set source and start loading
                    audioPlayer.src = audioURL;
                    
                    // Wait for loading to complete with timeout
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Audio loading timed out')), 5000);
                    });
                    
                    await Promise.race([loadPromise, timeoutPromise]);
                    
                    // Play the audio
                    await audioPlayer.play();
                    log('Audio playback started');
                    
                    showSuccess('Playing audio');
                    return true;
                } catch (error) {
                    log(`Error playing audio: ${error.message}`);
                    showError(`Failed to play audio: ${error.message}`);
                    return false;
                }
            }
        }
        
        // Global functions that interface with the classes
        function playWithTTSService(ttsService) {
            TTSServiceManager.playWithService(ttsService);
        }
        
        async function playAudio(base64Data) {
            await AudioPlayer.playFromBase64(base64Data);
        }
        
        // Audio comparison function removed
        
        function addMessageToUI(message) {
            const messagesContainer = document.getElementById('messages');
            const messageElement = document.createElement('div');
            messageElement.className = 'message';
            
            if (message.type === 'translation') {
                const sourceLanguageName = getLanguageName(message.sourceLanguage?.split('-')[0] || 'en');
                const targetLanguageName = getLanguageName(message.targetLanguage?.split('-')[0] || selectedLanguage);
                messageElement.innerHTML = `<div>${sourceLanguageName} → ${targetLanguageName}: "${message.text}"</div>`;
                
                if (message.originalText && message.originalText !== message.text) {
                    messageElement.innerHTML += `<div style="font-size:0.8em; color:#777;">Original: "${message.originalText}"</div>`;
                }
            } else if (message.type === 'tts_response') {
                // Don't display TTS responses in the messages list
                return;
            } else {
                messageElement.textContent = `${message.type}: ${JSON.stringify(message)}`;
            }
            
            messagesContainer.insertBefore(messageElement, messagesContainer.firstChild);
            
            // Limit the number of displayed messages
            while (messagesContainer.children.length > 20) {
                messagesContainer.removeChild(messagesContainer.lastChild);
            }
        }
        
        function updateActiveLanguage(languageCode) {
            // Remove active class from all language buttons
            document.querySelectorAll('.language-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to the selected language button
            const activeBtn = document.querySelector(`.language-btn[data-lang="${languageCode}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }
        
        function getLanguageName(code) {
            const languages = {
                'es': 'Spanish',
                'fr': 'French',
                'de': 'German',
                'it': 'Italian',
                'zh': 'Chinese',
                'ja': 'Japanese',
                'ru': 'Russian',
                'ar': 'Arabic',
                'pt': 'Portuguese',
                'ko': 'Korean'
            };
            
            return languages[code] || code;
        }
        
        // Initialize event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const connectBtn = document.getElementById('connect-btn');
            const disconnectBtn = document.getElementById('disconnect-btn');
            const languageSelect = document.getElementById('language-select');
            const currentTtsService = document.getElementById('current-tts-service');
            
            // Add CSS for unsupported languages
            const style = document.createElement('style');
            style.textContent = `
                .language-btn.unsupported {
                    opacity: 0.6;
                    background-color: #f8f8f8;
                    border-color: #ddd;
                    cursor: not-allowed;
                }
                .language-btn.unsupported:hover {
                    background-color: #f8f8f8;
                    border-color: #ddd;
                }
                option:disabled {
                    color: #999;
                    font-style: italic;
                }
            `;
            document.head.appendChild(style);
            
            // TTS service is now controlled by the teacher - initialize with default
            const defaultTtsService = 'browser'; // Default value until teacher's preference received
            
            // Initialize language support with default TTS service
            if (window.LanguageSupport) {
                window.LanguageSupport.updateDropdown(defaultTtsService);
                window.LanguageSupport.updateButtons(defaultTtsService);
            }
            
            // TTS service play example buttons removed - comparison feature no longer needed
            
            // Audio comparison functionality removed
            
            connectBtn.addEventListener('click', connectWebSocket);
            disconnectBtn.addEventListener('click', disconnectWebSocket);
            
            languageSelect.addEventListener('change', function() {
                selectedLanguage = this.value;
                if (isConnected) {
                    registerAsStudent(selectedLanguage);
                }
            });
            
            // No TTS service selection button handling needed anymore - teacher controls this
            
            // Quick language buttons
            document.querySelectorAll('.language-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const lang = this.getAttribute('data-lang');
                    
                    // Get the current teacher-controlled TTS service from the display span
                    const currentServiceName = document.getElementById('current-tts-service').textContent;
                    // Convert display name back to service ID using the helper function
                    const currentTtsService = getTtsServiceTypeFromName(currentServiceName);
                    
                    // Check if this language is supported by the current TTS service
                    if (window.LanguageSupport && !window.LanguageSupport.isSupported(lang, currentTtsService)) {
                        showError(`${this.textContent} is not supported by the current TTS service (${currentServiceName}). Please ask the teacher to change the TTS service.`);
                        return;
                    }
                    
                    // Update selected language
                    languageSelect.value = lang;
                    selectedLanguage = lang;
                    
                    // Update UI
                    document.querySelectorAll('.language-btn').forEach(button => {
                        button.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    if (isConnected) {
                        registerAsStudent(lang);
                        showSuccess(`Language changed to ${this.textContent}`);
                    }
                });
            });
            
            // Initialize modal for expanded language selection
            const showMoreBtn = document.getElementById('show-more-languages');
            const closeModalBtn = document.getElementById('close-modal');
            const languageModal = document.getElementById('language-modal');
            
            if (showMoreBtn && languageModal) {
                // Initialize the expanded language list when "More Languages" is clicked
                showMoreBtn.addEventListener('click', function() {
                    // Get the current teacher-controlled TTS service from the display span
                    const currentServiceName = document.getElementById('current-tts-service').textContent;
                    // Convert display name back to service ID using the helper function
                    const currentTtsService = getTtsServiceTypeFromName(currentServiceName);
                    
                    // Use the LanguageSupport module to update the expanded list
                    if (window.LanguageSupport) {
                        window.LanguageSupport.updateExpandedList(currentTtsService);
                    }
                    
                    // Show the modal
                    languageModal.style.display = 'block';
                });
                
                // Close modal button
                if (closeModalBtn) {
                    closeModalBtn.addEventListener('click', function() {
                        languageModal.style.display = 'none';
                    });
                }
                
                // Close modal when clicking outside
                window.addEventListener('click', function(event) {
                    if (event.target === languageModal) {
                        languageModal.style.display = 'none';
                    }
                });
            }
            
            log('Student page initialized with TTS service options');
        });
    </script>
</body>
</html>