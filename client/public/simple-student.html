<!DOCTYPE html>
<!-- 
    AIVoiceTranslator Student Interface
    
    Architecture Note: TTS service selection is now controlled by the teacher.
    Students can see which TTS service is active but cannot change it.
    They can play examples of different TTS services for comparison only.
    
    The architecture follows these principles:
    - Centralized control by the teacher for classroom consistency
    - Read-only display of TTS service selection for students
    - TTS comparison capabilities for educational purposes
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Student View - AIVoiceTranslator</title>
    <script src="js/language-support.js"></script>
    <style>
        :root {
            --primary-color: #3498db;
            --primary-dark: #2980b9;
            --primary-light: #e8f4fd;
            --secondary-color: #2ecc71;
            --secondary-dark: #27ae60;
            --error-color: #e74c3c;
            --warning-color: #f39c12;
            --text-color: #2c3e50;
            --text-light: #7f8c8d;
            --bg-color: #f5f8fa;
            --card-bg: white;
            --border-radius: 12px;
            --shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
        }
        
        /* Responsive Typography */
        html {
            font-size: 16px;
        }
        
        @media (max-width: 768px) {
            html {
                font-size: 14px;
            }
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s ease;
        }
        
        h1 {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 1.5rem;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 1px 1px rgba(0,0,0,0.05);
        }
        
        .container {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--shadow);
            margin-bottom: 30px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid rgba(0,0,0,0.05);
        }
        
        .container:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.12);
        }
        .translation-box {
            min-height: 150px;
            border: 1px solid rgba(0, 0, 0, 0.09);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 25px;
            background-color: #f9fafc;
            font-size: 1.2rem;
            line-height: 1.6;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }
        
        .translation-box:empty:before {
            content: "Teacher's speech will appear here...";
            color: var(--text-light);
            font-style: italic;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .translation-box:focus {
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05), 0 0 0 3px rgba(52, 152, 219, 0.3);
            outline: none;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        select {
            padding: 12px 15px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            font-size: 1rem;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
            color: var(--text-color);
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23131313%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 15px top 50%;
            background-size: 12px auto;
            padding-right: 30px;
        }
        
        select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.25);
            outline: none;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
        }
        
        button:disabled {
            background-color: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            font-weight: 600;
            font-size: 1.1rem;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: var(--border-radius);
            transition: background-color 0.3s ease;
        }
        
        .status.active {
            background-color: rgba(46, 204, 113, 0.1);
        }
        
        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
            position: relative;
        }
        
        .indicator.connected {
            background-color: var(--secondary-color);
            box-shadow: 0 0 0 rgba(46, 204, 113, 0.4);
            animation: pulse 2s infinite;
        }
        
        .indicator.disconnected {
            background-color: var(--error-color);
        }
        
        .indicator.connected:after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            border: 2px solid var(--secondary-color);
            opacity: 0.6;
            animation: pulse-ring 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        .language-heading {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 12px;
            width: 100%;
            color: var(--text-color);
            border-bottom: 1px solid rgba(0,0,0,0.05);
            padding-bottom: 8px;
        }
        
        .language-categories {
            margin-top: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .language-category {
            border-bottom: 1px solid #e0e0e0;
        }
        
        .language-category:last-child {
            border-bottom: none;
        }
        
        .category-header {
            padding: 10px 15px;
            background-color: #f8f9fa;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .category-header:hover {
            background-color: #e9ecef;
        }
        
        .category-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 5px;
            padding: 10px;
            background-color: #ffffff;
        }
        
        .language-option {
            padding: 8px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .language-option:hover {
            background-color: #f1f1f1;
        }
        
        .language-option.selected {
            background-color: #e3f2fd;
            color: #1565c0;
            font-weight: 500;
        }
        
        .chevron {
            transition: transform 0.3s;
        }
        
        .collapsed .chevron {
            transform: rotate(-90deg);
        }
        
        .language-btn {
            padding: 10px 16px;
            background-color: white;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 30px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .language-btn:hover:not(.unsupported) {
            background-color: var(--primary-light);
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 3px 5px rgba(0,0,0,0.08);
        }
        
        .language-btn.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-dark);
            box-shadow: 0 3px 5px rgba(0,0,0,0.1);
        }
        
        .language-btn.unsupported {
            opacity: 0.5;
            background-color: #f8f9fa;
            border-color: #e9ecef;
            cursor: not-allowed;
            position: relative;
        }
        
        .language-btn.unsupported:hover {
            background-color: #f8f9fa;
            border-color: #e9ecef;
            transform: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .language-btn.unsupported:after {
            content: '⚠️';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 10px;
            background: var(--warning-color);
            color: white;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .debug-log {
            margin-top: 30px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            background-color: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .log-entry {
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px dashed rgba(255,255,255,0.1);
        }
        
        .log-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        /* Modal styling */
        .language-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.75);
            z-index: 1000;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .language-modal.show {
            opacity: 1;
        }
        
        .language-modal .modal-content {
            position: relative;
            width: 90%;
            max-width: 900px;
            max-height: 85vh;
            overflow-y: auto;
            margin: 5% auto;
            background: white;
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transform: translateY(-20px);
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .language-modal.show .modal-content {
            transform: translateY(0);
            opacity: 1;
        }
        
        .language-modal .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .language-modal .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-color);
            margin: 0;
        }
        
        .language-modal .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.05);
            border: none;
            font-size: 22px;
            font-weight: bold;
            cursor: pointer;
            color: var(--text-color);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .language-modal .close-button:hover {
            background: rgba(0,0,0,0.1);
            transform: rotate(90deg);
        }
        
        .language-search {
            padding: 12px 15px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(0,0,0,0.1);
            font-size: 1rem;
            width: 100%;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .language-search:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(52,152,219,0.25);
            outline: none;
        }
        
        .language-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        
        .language-group {
            margin-bottom: 25px;
        }
        
        .language-group-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            color: var(--text-color);
        }
        
        .expanded-language-btn {
            padding: 12px 15px;
            text-align: left;
            background: white;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            font-weight: 500;
            position: relative;
        }
        
        .expanded-language-btn:hover:not(.unsupported) {
            background: var(--primary-light);
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 3px 5px rgba(0,0,0,0.08);
        }
        
        .expanded-language-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-dark);
            box-shadow: 0 3px 5px rgba(0,0,0,0.1);
        }
        
        .expanded-language-btn.unsupported {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #f8f9fa;
            position: relative;
        }
        
        .expanded-language-btn.unsupported:after {
            content: '⚠️';
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 10px;
            opacity: 0.8;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .header-links {
            display: flex;
            gap: 20px;
        }
        
        .header a {
            font-size: 0.95rem;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .header a:hover {
            color: var(--primary-dark);
        }
        
        .header a:after {
            content: '';
            position: absolute;
            width: 0;
            height: 2px;
            bottom: -5px;
            left: 0;
            background-color: var(--primary-color);
            transition: width 0.2s ease;
        }
        
        .header a:hover:after {
            width: 100%;
        }
        
        .messages {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: var(--border-radius);
            padding: 15px;
            margin-top: 20px;
            background-color: white;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .message {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            line-height: 1.4;
        }
        
        .message:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .error-message {
            background-color: rgba(231, 76, 60, 0.1);
            color: #c0392b;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            border-left: 4px solid var(--error-color);
            font-weight: 500;
        }
        
        .success-message {
            background-color: rgba(46, 204, 113, 0.1);
            color: #27ae60;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            border-left: 4px solid var(--secondary-color);
            font-weight: 500;
        }
        
        .audio-controls {
            margin-top: 25px;
            margin-bottom: 25px;
            display: flex;
            justify-content: center;
        }
        
        #play-button {
            background-color: var(--primary-dark);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.2s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }
        
        #play-button:hover {
            background-color: var(--primary-color);
            transform: translateY(-3px);
            box-shadow: 0 5px 12px rgba(0,0,0,0.2);
        }
        
        #play-button:active {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        
        #play-button:disabled {
            background-color: rgba(0,0,0,0.2);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .play-icon {
            font-size: 1.1rem;
        }
        
        @keyframes pulse-ring {
            0% {
                transform: scale(0.95);
                opacity: 0.7;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.3;
            }
            100% {
                transform: scale(0.95);
                opacity: 0.7;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Student Translator</h1>
        <div class="header-links">
            <a href="/"><span>←</span> Back to Home</a>
        </div>
    </div>
    
    <div class="container">
        <div id="error-container"></div>
        <div id="success-container"></div>
        
        <div class="status">
            <span id="connection-indicator" class="indicator disconnected"></span>
            <span id="connection-status">Disconnected</span>
        </div>
        
        <div class="controls">
            <button id="connect-btn">Connect</button>
            <button id="disconnect-btn" disabled>Disconnect</button>
            <!-- Keep a hidden select for backward compatibility - will be updated by the new dropdown -->
            <select id="language-select" style="display: none">
                <option value="en-US">English (United States)</option>
            </select>
        </div>
        
        <div>
            <div class="language-heading">Select Your Language</div>
            <div class="dropdown-language-selection">
                <div class="dropdown-menu">
                    <select id="simplified-language-select" class="language-dropdown" style="width: 100%;">
                        <option value="" disabled selected>Choose a language...</option>
                        <!-- Common Languages -->
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="zh">Chinese (Simplified)</option>
                        <option value="ja">Japanese</option>
                        <option value="ko">Korean</option>
                        <option value="ar">Arabic</option>
                        <option value="hi">Hindi</option>
                        <option value="pt">Portuguese</option>
                        <option value="ru">Russian</option>
                        <option value="it">Italian</option>
                        
                        <!-- Additional Languages (Alphabetical) -->
                        <option value="af">Afrikaans</option>
                        <option value="am">Amharic</option>
                        <option value="az">Azerbaijani</option>
                        <option value="be">Belarusian</option>
                        <option value="bg">Bulgarian</option>
                        <option value="bn">Bengali</option>
                        <option value="bs">Bosnian</option>
                        <option value="ca">Catalan</option>
                        <option value="cs">Czech</option>
                        <option value="da">Danish</option>
                        <option value="el">Greek</option>
                        <option value="et">Estonian</option>
                        <option value="fa">Persian</option>
                        <option value="fi">Finnish</option>
                        <option value="fil">Filipino</option>
                        <option value="gu">Gujarati</option>
                        <option value="he">Hebrew</option>
                        <option value="hr">Croatian</option>
                        <option value="hu">Hungarian</option>
                        <option value="hy">Armenian</option>
                        <option value="id">Indonesian</option>
                        <option value="is">Icelandic</option>
                        <option value="jv">Javanese</option>
                        <option value="ka">Georgian</option>
                        <option value="kk">Kazakh</option>
                        <option value="km">Khmer</option>
                        <option value="kn">Kannada</option>
                        <option value="lo">Lao</option>
                        <option value="lt">Lithuanian</option>
                        <option value="lv">Latvian</option>
                        <option value="mk">Macedonian</option>
                        <option value="ml">Malayalam</option>
                        <option value="mn">Mongolian</option>
                        <option value="mr">Marathi</option>
                        <option value="ms">Malay</option>
                        <option value="my">Burmese</option>
                        <option value="ne">Nepali</option>
                        <option value="nl">Dutch</option>
                        <option value="no">Norwegian</option>
                        <option value="pa">Punjabi</option>
                        <option value="pl">Polish</option>
                        <option value="ro">Romanian</option>
                        <option value="si">Sinhala</option>
                        <option value="sk">Slovak</option>
                        <option value="sl">Slovenian</option>
                        <option value="sq">Albanian</option>
                        <option value="sr">Serbian</option>
                        <option value="sv">Swedish</option>
                        <option value="sw">Swahili</option>
                        <option value="ta">Tamil</option>
                        <option value="te">Telugu</option>
                        <option value="th">Thai</option>
                        <option value="tr">Turkish</option>
                        <option value="uk">Ukrainian</option>
                        <option value="ur">Urdu</option>
                        <option value="uz">Uzbek</option>
                        <option value="vi">Vietnamese</option>
                        
                        <!-- Regional Variants -->
                        <option value="en-US">English (United States)</option>
                        <option value="en-GB">English (UK)</option>
                        <option value="en-AU">English (Australia)</option>
                        <option value="es-ES">Spanish (Spain)</option>
                        <option value="es-MX">Spanish (Mexico)</option>
                        <option value="pt-BR">Portuguese (Brazil)</option>
                        <option value="pt-PT">Portuguese (Portugal)</option>
                        <option value="fr-FR">French (France)</option>
                        <option value="fr-CA">French (Canada)</option>
                        <option value="zh-TW">Chinese (Traditional)</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="container" style="margin-top: 20px;">
            <div class="language-heading">Translated Speech</div>
            <div id="translation-box" class="translation-box">
                <p>Connect and select a language to receive translated speech from the teacher.</p>
            </div>
            
            <div class="audio-controls">
                <audio id="audio-player" controls style="display: none;"></audio>
                <button id="play-button" disabled>
                    <span class="play-icon">▶</span> Play Translation
                </button>
            </div>
        </div>
        
        <!-- Hidden language categories data -->
        <div class="hidden-language-data" style="display: none;">
            <div id="european-data">
                <option value="en">English</option>
                <option value="es">Spanish</option>
                <option value="fr">French</option>
                <option value="de">German</option>
                <option value="it">Italian</option>
                <option value="pt">Portuguese (EU)</option>
                <option value="nl">Dutch</option>
                <option value="ru">Russian</option>
                <option value="pl">Polish</option>
                <option value="sv">Swedish</option>
                <option value="cs">Czech</option>
                <option value="da">Danish</option>
                <option value="fi">Finnish</option>
                <option value="el">Greek</option>
                <option value="hu">Hungarian</option>
                <option value="ro">Romanian</option>
                <option value="no">Norwegian</option>
            </div>
            
            <div id="asian-data">
                <option value="zh">Chinese (Simplified)</option>
                <option value="zh-TW">Chinese (Traditional)</option>
                <option value="ja">Japanese</option>
                <option value="ko">Korean</option>
                <option value="hi">Hindi</option>
                <option value="bn">Bengali</option>
                <option value="ur">Urdu</option>
                <option value="te">Telugu</option>
                <option value="mr">Marathi</option>
                <option value="ta">Tamil</option>
                <option value="gu">Gujarati</option>
                <option value="kn">Kannada</option>
                <option value="ml">Malayalam</option>
                <option value="pa">Punjabi</option>
                <option value="th">Thai</option>
                <option value="vi">Vietnamese</option>
                <option value="id">Indonesian</option>
                <option value="ms">Malay</option>
                <option value="jv">Javanese</option>
                <option value="tl">Filipino</option>
                <option value="km">Khmer</option>
                <option value="my">Burmese</option>
                <option value="lo">Lao</option>
                <option value="fa">Persian</option>
                <option value="ne">Nepali</option>
                <option value="si">Sinhala</option>
                <option value="mn">Mongolian</option>
            </div>
            
            <div id="middle-east-data">
                <option value="ar">Arabic</option>
                <option value="ar-XA">Arabic (Multiple Regions)</option>
                <option value="he">Hebrew</option>
                <option value="tr">Turkish</option>
                <option value="am">Amharic</option>
                <option value="ha">Hausa</option>
                <option value="sw">Swahili</option>
                <option value="so">Somali</option>
                <option value="yo">Yoruba</option>
                <option value="zu">Zulu</option>
                <option value="ig">Igbo</option>
                <option value="af">Afrikaans</option>
            </div>
            
            <div id="americas-data">
                <option value="pt-BR">Portuguese (Brazil)</option>
                <option value="es-MX">Spanish (Mexico)</option>
                <option value="es-419">Spanish (Latin America)</option>
                <option value="fr-CA">French (Canada)</option>
                <option value="en-CA">English (Canada)</option>
                <option value="en-US">English (United States)</option>
                <option value="qu">Quechua</option>
                <option value="ay">Aymara</option>
                <option value="gn">Guarani</option>
                <option value="ht">Haitian Creole</option>
            </div>
            
            <div id="europe-variant-data">
                <option value="en-GB">English (UK)</option>
                <option value="pt-PT">Portuguese (Portugal)</option>
                <option value="es-ES">Spanish (Spain)</option>
                <option value="fr-FR">French (France)</option>
                <option value="de-DE">German (Germany)</option>
                <option value="it-IT">Italian (Italy)</option>
            </div>
        </div>
        
        <!-- Expanded Language Selection Modal -->
        <div id="language-modal" class="language-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">Choose Your Language</h2>
                    <button id="close-modal" class="close-button">×</button>
                </div>
                
                <input type="text" class="language-search" id="language-search" placeholder="Search for a language...">
                
                <div id="expanded-language-list" class="language-grid">
                    <!-- This will be populated dynamically -->
                </div>
            </div>
        </div>
        
        <div class="container" style="margin-top: 30px;">
            <div id="tts-service-info" style="margin-top: 15px;">
                <div id="active-tts-service-container" style="background-color: rgba(52, 152, 219, 0.1); border-left: 4px solid var(--primary-color); padding: 20px; border-radius: var(--border-radius); margin-bottom: 20px;">
                    <h3 style="margin-top: 0; color: var(--primary-color); font-size: 1.1rem;">Current Voice Service</h3>
                    <p style="margin-bottom: 10px;">
                        Your current voice service is:
                        <span id="current-tts-service" style="font-weight: bold; font-size: 1.1rem; color: var(--primary-color); display: inline-block; margin-left: 8px; padding: 3px 12px; background-color: rgba(52, 152, 219, 0.1); border-radius: 20px;">OpenAI</span>
                    </p>
                    <p style="margin-bottom: 0; font-size: 0.9rem; color: var(--text-light);">
                        Voice settings are managed by the teacher and synchronized for all students.
                    </p>
                </div>
            </div>
        </div>
        
        <!-- Audio comparison section removed to focus on core functionality -->
        
        <div class="container" style="margin-top: 30px;">
            <div class="language-heading">Connection Messages</div>
            <div id="messages" class="messages"></div>
        </div>
    </div>
    
    <div class="debug-log">
        <h3>Debug Log:</h3>
        <div id="log"></div>
    </div>
    
    <!-- Language support module -->
    <script src="/js/language-support.js"></script>
    
    <script>
        // Debug logging
        function log(message) {
            const logContainer = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(message);
        }
        
        // Show error message
        function showError(message) {
            const errorContainer = document.getElementById('error-container');
            errorContainer.innerHTML = `<div class="error-message">${message}</div>`;
            setTimeout(() => {
                errorContainer.innerHTML = '';
            }, 5000);
        }
        
        // Show success message
        function showSuccess(message) {
            const successContainer = document.getElementById('success-container');
            successContainer.innerHTML = `<div class="success-message">${message}</div>`;
            setTimeout(() => {
                successContainer.innerHTML = '';
            }, 5000);
        }
        
        // WebSocket Variables
        let socket;
        let isConnected = false;
        let sessionId = null;
        let selectedLanguage = document.getElementById('language-select').value;
        
        // Audio Cache - Store audio data by text and TTS service
        let audioCache = {
            lastTranslation: {
                text: "",
                originalText: "",
                audios: {}  // { "browser": { data: base64, url: blobUrl }, "openai": {...} }
            }
        };
        
        function connectWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                
                log(`Connecting to WebSocket at ${wsUrl}`);
                socket = new WebSocket(wsUrl);
                
                socket.onopen = function() {
                    log('WebSocket connection established');
                    isConnected = true;
                    updateConnectionUI(true);
                    showSuccess('Connected to classroom');
                    
                    // Register as student with selected language
                    registerAsStudent(selectedLanguage);
                };
                
                socket.onclose = function() {
                    log('WebSocket connection closed');
                    isConnected = false;
                    updateConnectionUI(false);
                };
                
                socket.onerror = function(error) {
                    log('WebSocket error: ' + JSON.stringify(error));
                    showError('Connection error. Please try again.');
                    isConnected = false;
                    updateConnectionUI(false);
                };
                
                socket.onmessage = function(event) {
                    const message = JSON.parse(event.data);
                    log('Received message: ' + JSON.stringify(message).substring(0, 200) + 
                        (JSON.stringify(message).length > 200 ? '... (truncated)' : ''));
                    
                    // Handle connection message with session ID
                    if (message.type === 'connection' && message.sessionId) {
                        sessionId = message.sessionId;
                        log(`Session ID: ${sessionId}`);
                    }
                    
                    // Handle translation message
                    if (message.type === 'translation') {
                        // Check if this is audio data from a server TTS service
                        const hasAudioData = message.audioData && message.audioData.length > 0;
                        const useClientSpeech = message.useClientSpeech === true;
                        const ttsServiceType = message.ttsServiceType || 'browser';
                        
                        log(`Received translation with TTS service: ${ttsServiceType}, hasAudio: ${hasAudioData}, useClientSpeech: ${useClientSpeech}`);
                        
                        // Update the displayed TTS service type (teacher's preference)
                        document.getElementById('current-tts-service').textContent = getTtsServiceName(ttsServiceType);
                        
                        // Store this translation data for audio comparison
                        window.lastTranslationData = {
                            text: message.text,
                            languageCode: message.targetLanguage,
                            ttsService: ttsServiceType,
                            originalText: message.originalText
                        };
                        
                        // If audio data is included, cache it
                        if (hasAudioData) {
                            const cacheKey = `${message.text}_${message.targetLanguage}_${ttsServiceType}`;
                            window.audioCache[cacheKey] = message.audioData;
                            log(`Cached audio for "${message.text.substring(0, 20)}..." with service ${ttsServiceType}`);
                        }
                        
                        // Display the translation text and handle audio depending on the service type
                        displayTranslation(
                            message.text, 
                            message.sourceLanguage, 
                            message.targetLanguage, 
                            message.originalText,
                            hasAudioData ? message.audioData : null,
                            useClientSpeech,
                            ttsServiceType
                        );
                    }
                    
                    // Handle TTS service audio response
                    if (message.type === 'tts_response') {
                        const ttsService = message.ttsService || 'openai';
                        const audioData = message.audioData;
                        
                        log(`Received TTS audio response from ${ttsService} service`);
                        
                        // Calculate latency from request time if available
                        if (window.ttsRequestTimes && window.ttsRequestTimes[ttsService]) {
                            const endTime = performance.now();
                            const startTime = window.ttsRequestTimes[ttsService];
                            const latency = Math.round(endTime - startTime);
                            
                            log(`${ttsService} TTS service latency: ${latency}ms`);
                            
                            // Record metrics if audio data exists
                            if (audioData && audioData.length > 0) {
                                // Calculate size in KB (base64 is 4/3 the size of binary)
                                const sizeInKB = (audioData.length * 3/4) / 1024;
                                
                                // Record metrics
                                TTSServiceManager.recordMetrics(ttsService, latency, sizeInKB);
                            }
                            
                            // Clear request time
                            delete window.ttsRequestTimes[ttsService];
                        }
                        
                        if (audioData && audioData.length > 0) {
                            try {
                                // Convert base64 to blob for playback
                                const binaryString = atob(audioData);
                                const bytes = new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    bytes[i] = binaryString.charCodeAt(i);
                                }
                                
                                // Create blob and URL
                                const blob = new Blob([bytes.buffer], { type: 'audio/mp3' }); 
                                const audioURL = URL.createObjectURL(blob);
                                
                                // Cache the audio data
                                audioCache.lastTranslation.audios[ttsService] = {
                                    data: audioData,
                                    url: audioURL,
                                    blob: blob,
                                    type: 'server',
                                    size: blob.size / 1024 // Size in KB
                                };
                                
                                // Play the audio
                                const audioPlayer = document.getElementById('audio-player');
                                audioPlayer.src = audioURL;
                                audioPlayer.play();
                                
                                // Show in comparison section
                                document.getElementById('audio-comparison').style.display = 'block';
                                updateAudioComparison();
                                
                                showSuccess(`Playing with ${getTtsServiceName(ttsService)}`);
                            } catch (error) {
                                log(`Error processing ${ttsService} audio: ${error.message}`);
                                showError(`Failed to process ${getTtsServiceName(ttsService)} audio`);
                            }
                        } else {
                            log(`No audio data received from ${ttsService} service`);
                            showError(`No audio received from ${getTtsServiceName(ttsService)}`);
                        }
                    }
                    
                    // Add message to UI
                    addMessageToUI(message);
                };
            } catch (error) {
                log('Error creating WebSocket: ' + error.message);
                showError('Failed to establish connection: ' + error.message);
            }
        }
        
        function disconnectWebSocket() {
            if (socket) {
                log('Disconnecting WebSocket');
                socket.close();
            }
        }
        
        function registerAsStudent(languageCode) {
            if (!isConnected) {
                log('Cannot register, WebSocket not connected');
                showError('Not connected to classroom');
                return;
            }
            
            const message = {
                type: 'register',
                role: 'student',
                languageCode: languageCode
                // No TTS service settings - controlled by teacher
            };
            
            log(`Registering as student with language ${languageCode}`);
            socket.send(JSON.stringify(message));
            showSuccess(`Receiving translations in ${getLanguageName(languageCode)}`);
            
            // Update UI to show active language
            updateActiveLanguage(languageCode);
        }
        
        // Get a user-friendly name for the TTS service
        function getTtsServiceName(serviceType) {
            const serviceNames = {
                'browser': 'Browser Speech',
                'openai': 'OpenAI TTS (Emotions)',
                'silent': 'Silent Mode'
            };
            
            return serviceNames[serviceType] || serviceType;
        }
        
        // Convert a display name back to a service type
        function getTtsServiceTypeFromName(displayName) {
            let serviceType = 'browser'; // Default fallback
            if (displayName.includes('OpenAI')) {
                serviceType = 'openai';
            } else if (displayName.includes('Silent')) {
                serviceType = 'silent';
            }
            return serviceType;
        }
        
        function updateConnectionUI(connected) {
            const connectBtn = document.getElementById('connect-btn');
            const disconnectBtn = document.getElementById('disconnect-btn');
            const indicator = document.getElementById('connection-indicator');
            const status = document.getElementById('connection-status');
            
            if (connected) {
                indicator.className = 'indicator connected';
                status.textContent = 'Connected to Classroom';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
            } else {
                indicator.className = 'indicator disconnected';
                status.textContent = 'Disconnected';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
            }
        }
        
        function displayTranslation(text, sourceLanguage, targetLanguage, originalText, audioData = null, useClientSpeech = false, ttsServiceType = 'browser') {
            const translationBox = document.getElementById('translation-box');
            const audio = document.getElementById('audio-player');
            const playButton = document.getElementById('play-button');
            const comparisonSection = document.getElementById('audio-comparison');
            
            // Update the cache with this new translation
            audioCache.lastTranslation.text = text;
            audioCache.lastTranslation.originalText = originalText || "";
            audioCache.lastTranslation.targetLanguage = targetLanguage;
            
            // Create HTML with both original and translated text
            let html = '';
            if (originalText) {
                html += `<p style="color: #777; font-size: 0.9em; margin-bottom: 5px;">Original: "${originalText}"</p>`;
            }
            html += `<p style="font-size: 1.2em; font-weight: bold;">${text}</p>`;
            
            // Add a label showing which TTS service is being used
            html += `<p style="color: #666; font-size: 0.8em; text-align: right; margin-top: 5px;">
                        Audio: ${getTtsServiceName(ttsServiceType)}
                     </p>`;
            
            translationBox.innerHTML = html;
            
            // Highlight the translation
            translationBox.style.animation = 'none';
            setTimeout(() => {
                translationBox.style.animation = 'highlight 1s';
            }, 10);
            
            // Add CSS for the highlight animation if it doesn't exist
            if (!document.getElementById('highlight-animation')) {
                const style = document.createElement('style');
                style.id = 'highlight-animation';
                style.textContent = `
                    @keyframes highlight {
                        0% { background-color: #e3f2fd; }
                        100% { background-color: #f9f9f9; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Handle audio based on the TTS service type
            if (ttsServiceType === 'silent') {
                // Silent mode - disable audio playback
                playButton.disabled = true;
                playButton.innerHTML = '<span class="play-icon">🔇</span> Audio Disabled';
                log('Silent mode active, no audio playback');
                
                // Store in cache that this service is silent
                audioCache.lastTranslation.audios[ttsServiceType] = { 
                    isSilent: true
                };
            } else if (audioData && audioData.length > 0) {
                // We have server-generated audio data (base64 encoded)
                try {
                    log('Received server-generated audio data, preparing for playback');
                    
                    // Log audio data details before processing
                    log(`Processing audio data: length=${audioData.length} chars, first 50 chars: ${audioData.substring(0, 50)}...`);
                    
                    // Make sure the audioData is actually a base64 string
                    // Sometimes it might be sent with a data URL prefix, so we need to remove it
                    let cleanBase64 = audioData;
                    if (audioData.startsWith('data:')) {
                        // Extract the base64 part from the data URL
                        const commaIndex = audioData.indexOf(',');
                        if (commaIndex !== -1) {
                            cleanBase64 = audioData.substring(commaIndex + 1);
                            log('Extracted base64 data from data URL');
                        }
                    }
                    
                    // Variables to store the processed binary data
                    let bytes = null;
                    let headerHex = '';
                    
                    try {
                        // Convert base64 to a blob
                        const binaryString = atob(cleanBase64);
                        log(`Converted binary string length: ${binaryString.length} bytes`);
                        
                        bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        
                        // Check header bytes to determine format (MP3 starts with ID3 or 0xFF 0xFB)
                        headerHex = Array.from(bytes.slice(0, 4))
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join(' ');
                        log(`Audio data header: ${headerHex}`);
                    } catch (error) {
                        log(`WARNING: Failed to decode base64 data: ${error.message}`);
                        throw new Error(`Failed to decode audio data: ${error.message}`);
                    }
                    
                    // Make sure we got valid binary data
                    if (!bytes || bytes.length === 0) {
                        throw new Error('Failed to create valid binary data from base64');
                    }
                    
                    // Determine MIME type based on header
                    let mimeType = 'audio/mp3'; // Default assumption
                    if (headerHex.startsWith('49 44 33')) { // ID3
                        mimeType = 'audio/mp3';
                        log('Detected MP3 audio with ID3 tag');
                    } else if (headerHex.startsWith('ff fb')) {
                        mimeType = 'audio/mp3';
                        log('Detected MP3 audio without ID3 tag');
                    } else if (headerHex.startsWith('52 49 46 46')) { // RIFF
                        mimeType = 'audio/wav';
                        log('Detected WAV audio');
                    } else {
                        log(`Unknown audio format with header: ${headerHex}`);
                    }
                    
                    // Create blob with detected MIME type
                    const blob = new Blob([bytes.buffer], { type: mimeType });
                    log(`Created audio blob: size=${blob.size} bytes, type=${mimeType}`);
                    
                    const audioURL = URL.createObjectURL(blob);
                    
                    // Cache the audio data
                    audioCache.lastTranslation.audios[ttsServiceType] = {
                        data: audioData,
                        url: audioURL,
                        blob: blob,
                        type: 'server'
                    };
                    
                    // Set up audio element and play button
                    audio.src = audioURL;
                    playButton.disabled = false;
                    
                    // Update button to show which TTS service is being used
                    playButton.innerHTML = `<span class="play-icon">▶</span> Play Translation (${getTtsServiceName(ttsServiceType)})`;
                    
                    // Define handler for audio playback
                    const playAudio = () => {
                        log(`Playing server-generated audio (${ttsServiceType} TTS)`);
                        audio.play().catch(err => {
                            log('Error playing audio: ' + err.message);
                            showError('Audio playback failed: ' + err.message);
                        });
                        
                        // Visual feedback during playback
                        playButton.style.backgroundColor = '#e74c3c';
                        playButton.innerHTML = '<span class="play-icon">🔊</span> Playing...';
                    };
                    
                    // Set up click handler for play button
                    // Store a reference to the current TTS service type so it remains consistent
                    playButton.onclick = playAudio;
                    
                    // Reset button when audio ends - preserve the TTS service information
                    audio.onended = () => {
                        playButton.style.backgroundColor = '';
                        playButton.innerHTML = `<span class="play-icon">▶</span> Play Translation (${getTtsServiceName(ttsServiceType)})`;
                    };
                    
                    // Auto-play for OpenAI TTS when that service is selected
                    if (ttsServiceType === 'openai') {
                        log('Auto-playing OpenAI TTS audio');
                        // Slight delay to make sure audio is loaded
                        setTimeout(playAudio, 300);
                        showSuccess('Playing OpenAI translation audio');
                    } else {
                        showSuccess('Server-generated audio ready to play');
                    }
                    
                    // Show the comparison section now that we have some audio
                    comparisonSection.style.display = 'block';
                    updateAudioComparison();
                } catch (error) {
                    log('Error processing audio data: ' + error.message);
                    // Fall back to browser speech synthesis
                    generateSpeechFromText(text, targetLanguage);
                }
            } else if (useClientSpeech) {
                // Explicitly instructed to use client speech synthesis
                log('Server explicitly requested client-side speech synthesis');
                
                // Check if we have speech parameters with autoPlay flag
                if (message && message.speechParams && message.speechParams.autoPlay === true) {
                    log('Auto-playing browser speech synthesis due to autoPlay flag');
                    generateSpeechFromText(text, targetLanguage, ttsServiceType);
                } else {
                    // Still configure the play button to use speech synthesis when clicked
                    log('Browser speech synthesis ready (click play button to hear)');
                    playButton.disabled = false;
                    playButton.onclick = () => generateSpeechFromText(text, targetLanguage, ttsServiceType);
                }
            } else if (ttsServiceType === 'openai' && !audioData) {
                // We're supposed to use OpenAI TTS but didn't receive audio data - request it from server
                log('OpenAI TTS selected but no audio data received - trying to request it from server');
                TTSServiceManager.requestServerTTS(text, targetLanguage, 'openai', performance.now());
            } else {
                // We don't have audio data and no explicit instruction to use client speech
                if (ttsServiceType === 'browser') {
                    // For browser TTS service, use the browser speech synthesis
                    log('Using browser speech synthesis for browser TTS service');
                    generateSpeechFromText(text, targetLanguage, ttsServiceType);
                } else if (ttsServiceType === 'openai') {
                    // For OpenAI TTS service with no audio, try to request from server first
                    log('OpenAI TTS service selected but no audio available - requesting from server');
                    
                    // Set up a fallback just in case
                    playButton.disabled = false;
                    playButton.innerHTML = '<span class="play-icon">▶</span> Play Translation (OpenAI)';
                    
                    // When clicked, try to get OpenAI audio first
                    playButton.onclick = () => {
                        log('Requesting OpenAI TTS audio from server for play button');
                        TTSServiceManager.requestServerTTS(text, targetLanguage, 'openai', performance.now());
                    };
                    
                    // Also try to request it immediately
                    TTSServiceManager.requestServerTTS(text, targetLanguage, 'openai', performance.now());
                } else {
                    // For any other TTS service, provide a consistent fallback
                    log('No audio data available for ' + ttsServiceType + ' service, using consistent fallback');
                    generateSpeechFromText(text, targetLanguage, ttsServiceType);
                }
            }
        }
        
        // Function to update audio comparison UI
        function updateAudioComparison() {
            const comparisonOptions = document.getElementById('comparison-options');
            comparisonOptions.innerHTML = '';
            
            // Get available TTS services with audio for the current translation
            const audioServices = Object.keys(audioCache.lastTranslation.audios);
            
            if (audioServices.length === 0) {
                comparisonOptions.innerHTML = '<p>No audio available for comparison yet.</p>';
                return;
            }
            
            // Create a player for each available TTS service
            audioServices.forEach(service => {
                const audioInfo = audioCache.lastTranslation.audios[service];
                
                // Skip if this is silent mode
                if (audioInfo.isSilent) {
                    return;
                }
                
                const serviceCard = document.createElement('div');
                serviceCard.className = 'service-comparison-card';
                serviceCard.style.padding = '15px';
                serviceCard.style.backgroundColor = '#f5f8fa';
                serviceCard.style.borderRadius = '8px';
                serviceCard.style.border = '1px solid #e1e4e8';
                
                // Create audio element 
                const audioElement = document.createElement('audio');
                audioElement.style.width = '100%';
                audioElement.controls = true;
                
                if (audioInfo.url) {
                    audioElement.src = audioInfo.url;
                }
                
                // Create service info
                const serviceInfo = document.createElement('div');
                serviceInfo.style.display = 'flex';
                serviceInfo.style.justifyContent = 'space-between';
                serviceInfo.style.alignItems = 'center';
                serviceInfo.style.marginBottom = '10px';
                
                const serviceName = document.createElement('h4');
                serviceName.style.margin = '0';
                serviceName.textContent = getTtsServiceName(service);
                
                const serviceBadge = document.createElement('span');
                serviceBadge.style.backgroundColor = service === 'openai' ? '#6366f1' : '#3498db';
                serviceBadge.style.color = 'white';
                serviceBadge.style.padding = '3px 8px';
                serviceBadge.style.borderRadius = '12px';
                serviceBadge.style.fontSize = '12px';
                serviceBadge.textContent = service === 'openai' ? 'Emotional' : 'Standard';
                
                serviceInfo.appendChild(serviceName);
                serviceInfo.appendChild(serviceBadge);
                
                // Add elements to card
                serviceCard.appendChild(serviceInfo);
                serviceCard.appendChild(audioElement);
                
                // Add card to options
                comparisonOptions.appendChild(serviceCard);
            });
        }
        
        // Play with a specific TTS service
        async function playWithTTSService(ttsService) {
            const translationText = audioCache.lastTranslation.text;
            const targetLanguage = audioCache.lastTranslation.targetLanguage;
            
            if (!translationText || !targetLanguage) {
                showError('No translation available to play');
                return;
            }
            
            log(`Playing translation with ${getTtsServiceName(ttsService)} service`);
            
            if (ttsService === 'silent') {
                showSuccess('Silent mode - no audio played');
                return;
            }
            
            // If we already have this audio cached, use it
            if (audioCache.lastTranslation.audios[ttsService]) {
                const cachedAudio = audioCache.lastTranslation.audios[ttsService];
                
                if (cachedAudio.url) {
                    const audioPlayer = document.getElementById('audio-player');
                    audioPlayer.src = cachedAudio.url;
                    audioPlayer.play();
                    showSuccess(`Playing with ${getTtsServiceName(ttsService)}`);
                    return;
                }
            }
            
            // For browser TTS, use speech synthesis
            if (ttsService === 'browser') {
                if ('speechSynthesis' in window) {
                    // Create the utterance
                    const utterance = new SpeechSynthesisUtterance(translationText);
                    
                    // Set language code, mapping short codes to full BCP 47 language tags if needed
                    const langCodeMap = {
                        'es': 'es-ES',
                        'fr': 'fr-FR',
                        'de': 'de-DE',
                        'it': 'it-IT',
                        'zh': 'zh-CN',
                        'ja': 'ja-JP',
                        'ru': 'ru-RU',
                        'ar': 'ar-SA',
                        'pt': 'pt-BR',
                        'ko': 'ko-KR',
                        'en': 'en-US'
                    };
                    
                    // Map short language code to full code, or use as is if already in right format
                    utterance.lang = langCodeMap[targetLanguage] || targetLanguage;
                    
                    // Speak the text
                    speechSynthesis.speak(utterance);
                    
                    // Cache this for later comparison (empty data/url as we can't capture it)
                    audioCache.lastTranslation.audios['browser'] = {
                        type: 'browser',
                        data: null,
                        url: null
                    };
                    
                    showSuccess('Playing with Browser TTS');
                } else {
                    showError('Browser does not support speech synthesis');
                }
                return;
            }
            
            // For OpenAI or other server-based TTS, re-register with that service
            if (isConnected) {
                // Send a request to get audio for the current translation but with a different TTS service
                const message = {
                    type: 'tts_request',
                    text: translationText,
                    languageCode: targetLanguage,
                    ttsService: ttsService,
                    originalText: audioCache.lastTranslation.originalText || ""
                };
                
                socket.send(JSON.stringify(message));
                showSuccess(`Requesting audio with ${getTtsServiceName(ttsService)}...`);
            } else {
                showError('Cannot use server TTS services while disconnected');
            }
        }
        
        // Generate speech from text using browser's Speech Synthesis API (Web Speech API)
        function generateSpeechFromText(text, languageCode, ttsServiceType = 'browser') {
            const audio = document.getElementById('audio-player');
            const playButton = document.getElementById('play-button');
            
            // Log the TTS service type being used
            log(`Generating speech with service type: ${ttsServiceType}`);
            
            // If OpenAI TTS was selected but we're still using browser speech,
            // this means there was an issue with the server-generated audio
            if (ttsServiceType === 'openai') {
                log('WARNING: Fallback to browser speech despite OpenAI TTS selection');
                showWarning('Using browser speech as fallback (server audio unavailable)');
            }
            
            // Disable button during processing
            playButton.disabled = true;
            
            try {
                // Check if the browser supports speech synthesis
                if ('speechSynthesis' in window) {
                    log('Web Speech API available, generating audio...');
                    
                    // Create the utterance
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    // Set language code, mapping short codes to full BCP 47 language tags if needed
                    const langCodeMap = {
                        'es': 'es-ES',
                        'fr': 'fr-FR',
                        'de': 'de-DE',
                        'it': 'it-IT',
                        'zh': 'zh-CN',
                        'ja': 'ja-JP',
                        'ru': 'ru-RU',
                        'ar': 'ar-SA',
                        'pt': 'pt-BR',
                        'ko': 'ko-KR',
                        'en': 'en-US'
                    };
                    
                    // Map short language code to full code, or use as is if already in right format
                    utterance.lang = langCodeMap[languageCode] || languageCode;
                    
                    // Store audio as blob using MediaRecorder
                    let chunks = [];
                    
                    // Create audio context and media stream destination
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const destination = audioContext.createMediaStreamDestination();
                    
                    // Create oscillator and gain (to capture speech synthesis)
                    // This is a workaround since we can't directly capture SpeechSynthesis output
                    const oscillator = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    oscillator.connect(gain);
                    gain.connect(destination);
                    
                    // Setup MediaRecorder to capture the audio
                    const mediaRecorder = new MediaRecorder(destination.stream);
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            chunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        // Create a blob from all the chunks
                        const blob = new Blob(chunks, { type: 'audio/wav' });
                        const audioURL = URL.createObjectURL(blob);
                        
                        // Set the audio source and make play button visible
                        audio.src = audioURL;
                        playButton.disabled = false;
                        
                        log('Audio generation completed, ready for playback');
                    };
                    
                    // Force using speech synthesis directly instead for now
                    // The MediaRecorder approach works in theory but is complex and unreliable across browsers

                    // Create a simpler approach: we'll return immediately with a playable button,
                    // and the button will trigger speech synthesis on demand
                    playButton.disabled = false;
                    playButton.onclick = () => {
                        log(`Playing translation audio in ${utterance.lang}`);
                        window.speechSynthesis.cancel(); // Cancel any ongoing speech
                        window.speechSynthesis.speak(utterance);
                        
                        // Visual feedback during playback
                        playButton.style.backgroundColor = '#e74c3c';
                        playButton.innerHTML = '<span class="play-icon">🔊</span> Playing...';
                        
                        // Reset button when done
                        utterance.onend = () => {
                            playButton.style.backgroundColor = '';
                            playButton.innerHTML = '<span class="play-icon">▶</span> Play Translation';
                        };
                    };
                    
                    log(`Audio ready for playback in language: ${utterance.lang}`);
                    showSuccess('Translation audio ready to play');
                } else {
                    // No speech synthesis support
                    log('Speech synthesis not supported in this browser');
                    showError('Audio playback not supported in your browser');
                    playButton.disabled = true;
                }
            } catch (error) {
                log('Error generating speech: ' + error.message);
                showError('Failed to generate speech audio');
                playButton.disabled = true;
            }
        }
        
        /**
         * TTS Service Manager
         * 
         * Refactored to follow separation of concerns and improve maintainability.
         * This class handles all TTS service related operations.
         */
        class TTSServiceManager {
            // Store metrics for TTS services
            static metrics = {
                browser: {
                    latency: [],
                    fileSize: []
                },
                openai: {
                    latency: [],
                    fileSize: []
                }
            };
            
            /**
             * Play audio with a specific TTS service
             * 
             * @param {string} ttsService - The TTS service to use (browser, openai, silent)
             */
            static playWithService(ttsService) {
                // Validate required data
                if (!this.validateTranslationData()) {
                    return;
                }
                
                const text = window.lastTranslationData.text;
                const languageCode = window.lastTranslationData.languageCode;
                
                log(`Requesting TTS service ${ttsService} to play: "${text.substring(0, 20)}..."`);
                
                // Check cache first
                if (this.checkAndUseCache(text, languageCode, ttsService)) {
                    return;
                }
                
                // Start latency measurement
                const startTime = performance.now();
                
                // Handle different service types
                switch (ttsService) {
                    case 'silent':
                        this.handleSilentMode();
                        break;
                    case 'browser':
                        this.useBrowserSpeechSynthesis(text, languageCode, startTime);
                        break;
                    default:
                        this.requestServerTTS(text, languageCode, ttsService, startTime);
                        break;
                }
            }
            
            /**
             * Validate that we have translation data to use
             * 
             * @returns {boolean} True if valid data exists
             */
            static validateTranslationData() {
                if (!window.lastTranslationData || !window.lastTranslationData.text) {
                    showError('No translation available to play');
                    return false;
                }
                return true;
            }
            
            /**
             * Check if audio is in cache and use it if available
             * 
             * @param {string} text - The text to play
             * @param {string} languageCode - The language code
             * @param {string} ttsService - The TTS service
             * @returns {boolean} True if cache was used
             */
            static checkAndUseCache(text, languageCode, ttsService) {
                const cacheKey = `${text}_${languageCode}_${ttsService}`;
                if (window.audioCache[cacheKey]) {
                    log(`Using cached audio for service ${ttsService}`);
                    AudioPlayer.playFromBase64(window.audioCache[cacheKey]);
                    return true;
                }
                return false;
            }
            
            /**
             * Handle silent mode (no audio)
             */
            static handleSilentMode() {
                showSuccess('Silent mode - no audio played');
            }
            
            /**
             * Use browser's built-in speech synthesis
             * 
             * @param {string} text - The text to speak
             * @param {string} languageCode - The language code
             * @param {number} startTime - Start time for latency measurement
             */
            static useBrowserSpeechSynthesis(text, languageCode, startTime) {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = languageCode || 'en-US';
                    utterance.rate = 1.0;
                    utterance.pitch = 1.0;
                    
                    // Measure audio size (estimate since browser API doesn't provide size)
                    const estimatedSize = text.length * 0.1; // Rough estimate - 0.1KB per character
                    
                    // Add event listener for when speech starts
                    utterance.onstart = () => {
                        const endTime = performance.now();
                        const latency = Math.round(endTime - startTime);
                        
                        // Record metrics
                        this.recordMetrics('browser', latency, estimatedSize);
                        
                        log(`Browser TTS latency: ${latency}ms, estimated size: ${estimatedSize.toFixed(1)}KB`);
                    };
                    
                    log(`Using browser speech synthesis for language ${languageCode}`);
                    speechSynthesis.speak(utterance);
                    
                    showSuccess('Playing with browser speech synthesis');
                } else {
                    showError('Browser speech synthesis not available');
                }
            }
            
            /**
             * Request TTS from server
             * 
             * @param {string} text - The text to speak
             * @param {string} languageCode - The language code
             * @param {string} ttsService - The TTS service to use
             * @param {number} startTime - Start time for latency measurement
             */
            static requestServerTTS(text, languageCode, ttsService, startTime) {
                if (isConnected) {
                    const ttsRequest = {
                        type: 'tts_request',
                        text: text,
                        languageCode: languageCode,
                        ttsService: ttsService
                    };
                    
                    // Store start time in global object to be retrieved when response arrives
                    window.ttsRequestTimes = window.ttsRequestTimes || {};
                    window.ttsRequestTimes[ttsService] = startTime;
                    
                    socket.send(JSON.stringify(ttsRequest));
                    showSuccess(`Requesting audio from ${getTtsServiceName(ttsService)}...`);
                } else {
                    showError('Connect to classroom first to use this TTS service');
                }
            }
            
            /**
             * Record metrics for a TTS service
             * 
             * @param {string} service - The TTS service (browser, openai)
             * @param {number} latency - Latency in milliseconds
             * @param {number} fileSize - File size in KB
             */
            static recordMetrics(service, latency, fileSize) {
                if (this.metrics[service]) {
                    // Add to metrics arrays (keep last 5 values for average)
                    this.metrics[service].latency.push(latency);
                    if (this.metrics[service].latency.length > 5) {
                        this.metrics[service].latency.shift();
                    }
                    
                    this.metrics[service].fileSize.push(fileSize);
                    if (this.metrics[service].fileSize.length > 5) {
                        this.metrics[service].fileSize.shift();
                    }
                    
                    // Update UI with average values
                    this.updateMetricsUI();
                }
            }
            
            /**
             * Calculate average of array values
             * 
             * @param {Array<number>} arr - Array of numbers
             * @returns {number} Average value
             */
            static calculateAverage(arr) {
                if (!arr || arr.length === 0) return 0;
                const sum = arr.reduce((a, b) => a + b, 0);
                return sum / arr.length;
            }
            
            /**
             * Update metrics UI with current values
             */
            static updateMetricsUI() {
                // Calculate averages
                const browserLatencyAvg = this.calculateAverage(this.metrics.browser.latency);
                const openaiLatencyAvg = this.calculateAverage(this.metrics.openai.latency);
                const browserSizeAvg = this.calculateAverage(this.metrics.browser.fileSize);
                const openaiSizeAvg = this.calculateAverage(this.metrics.openai.fileSize);
                
                // Update UI elements
                document.getElementById('browser-latency').textContent = 
                    browserLatencyAvg > 0 ? `${Math.round(browserLatencyAvg)}ms` : '-';
                
                document.getElementById('openai-latency').textContent = 
                    openaiLatencyAvg > 0 ? `${Math.round(openaiLatencyAvg)}ms` : '-';
                
                document.getElementById('browser-size').textContent = 
                    browserSizeAvg > 0 ? `${browserSizeAvg.toFixed(1)}KB` : '-';
                
                document.getElementById('openai-size').textContent = 
                    openaiSizeAvg > 0 ? `${openaiSizeAvg.toFixed(1)}KB` : '-';
            }
            
            /**
             * Update the audio comparison UI
             */
            static updateComparisonUI() {
                const comparisonContainer = document.getElementById('comparison-options');
                if (!comparisonContainer) return;
                
                if (!window.lastTranslationData || !window.lastTranslationData.text) {
                    comparisonContainer.innerHTML = '<p>No translation available for comparison</p>';
                    return;
                }
                
                const text = window.lastTranslationData.text;
                const languageCode = window.lastTranslationData.languageCode;
                
                // Create comparison UI
                let html = `
                    <div style="border-bottom: 1px solid #ddd; padding-bottom: 10px; margin-bottom: 10px;">
                        <p><strong>Text:</strong> "${text}"</p>
                        <p><strong>Language:</strong> ${getLanguageName(languageCode?.split('-')[0] || 'en')}</p>
                    </div>
                `;
                
                // Add buttons for each service
                html += `
                    <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                        <button onclick="TTSServiceManager.playWithService('browser')" class="comparison-btn" style="background-color: #3498db;">
                            <span>🔊</span> Browser Speech
                        </button>
                        <button onclick="TTSServiceManager.playWithService('openai')" class="comparison-btn" style="background-color: #6366f1;">
                            <span>🔊</span> OpenAI TTS
                        </button>
                        <button onclick="TTSServiceManager.playWithService('silent')" class="comparison-btn" style="background-color: #95a5a6;">
                            <span>🔇</span> Silent Mode
                        </button>
                    </div>
                `;
                
                comparisonContainer.innerHTML = html;
                
                // Also ensure metrics UI is updated
                this.updateMetricsUI();
            }
        }
        
        /**
         * Audio Player Utility Class
         * 
         * Handles all audio playback operations
         */
        class AudioPlayer {
            /**
             * Play audio from base64 encoded data with improved error handling
             * 
             * @param {string} base64Data - Base64 encoded audio data
             * @returns {Promise<boolean>} - Promise that resolves to true if playback started successfully
             */
            static async playFromBase64(base64Data) {
                try {
                    log(`Playing audio from base64, data length: ${base64Data.length} chars`);
                    log(`First 20 chars of base64: ${base64Data.substring(0, 20)}...`);
                    
                    // Convert base64 to blob for playback
                    const binaryString = atob(base64Data);
                    log(`Converted to binary string of length: ${binaryString.length}`);
                    
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    
                    // Check header bytes to determine format
                    const headerHex = Array.from(bytes.slice(0, 4))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join(' ');
                    log(`Audio data header: ${headerHex}`);
                    
                    // Determine MIME type based on header
                    let mimeType = 'audio/mp3'; // Default assumption
                    
                    if (headerHex.startsWith('49 44 33')) { // ID3
                        mimeType = 'audio/mp3';
                        log('Detected MP3 audio with ID3 tag');
                    } else if (headerHex.startsWith('ff fb')) {
                        mimeType = 'audio/mp3';
                        log('Detected MP3 audio without ID3 tag');
                    } else if (headerHex.startsWith('52 49 46 46')) { // RIFF
                        mimeType = 'audio/wav';
                        log('Detected WAV audio');
                    } else {
                        log(`Unknown audio format with header: ${headerHex}`);
                    }
                    
                    // Create blob with detected MIME type
                    const blob = new Blob([bytes.buffer], { type: mimeType });
                    log(`Created audio blob: size=${blob.size} bytes, type=${mimeType}`);
                    
                    const audioURL = URL.createObjectURL(blob);
                    
                    // Get the audio player
                    const audioPlayer = document.getElementById('audio-player');
                    
                    // Set up promise to track audio loading status
                    const loadPromise = new Promise((resolve, reject) => {
                        // Handle successful loading
                        audioPlayer.onloadeddata = () => {
                            log('Audio loaded successfully');
                            resolve(true);
                        };
                        
                        // Handle errors
                        audioPlayer.onerror = (e) => {
                            const errorMessage = `Audio error: ${audioPlayer.error ? audioPlayer.error.code : 'unknown'}`;
                            log(errorMessage);
                            reject(new Error(errorMessage));
                        };
                    });
                    
                    // Set source and start loading
                    audioPlayer.src = audioURL;
                    
                    // Wait for loading to complete with timeout
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Audio loading timed out')), 5000);
                    });
                    
                    await Promise.race([loadPromise, timeoutPromise]);
                    
                    // Play the audio
                    await audioPlayer.play();
                    log('Audio playback started');
                    
                    showSuccess('Playing audio');
                    return true;
                } catch (error) {
                    log(`Error playing audio: ${error.message}`);
                    showError(`Failed to play audio: ${error.message}`);
                    return false;
                }
            }
        }
        
        // Global functions that interface with the classes
        function playWithTTSService(ttsService) {
            TTSServiceManager.playWithService(ttsService);
        }
        
        async function playAudio(base64Data) {
            await AudioPlayer.playFromBase64(base64Data);
        }
        
        function updateAudioComparison() {
            TTSServiceManager.updateComparisonUI();
        }
        
        function addMessageToUI(message) {
            const messagesContainer = document.getElementById('messages');
            const messageElement = document.createElement('div');
            messageElement.className = 'message';
            
            if (message.type === 'translation') {
                const sourceLanguageName = getLanguageName(message.sourceLanguage?.split('-')[0] || 'en');
                const targetLanguageName = getLanguageName(message.targetLanguage?.split('-')[0] || selectedLanguage);
                messageElement.innerHTML = `<div>${sourceLanguageName} → ${targetLanguageName}: "${message.text}"</div>`;
                
                if (message.originalText && message.originalText !== message.text) {
                    messageElement.innerHTML += `<div style="font-size:0.8em; color:#777;">Original: "${message.originalText}"</div>`;
                }
            } else if (message.type === 'tts_response') {
                // Don't display TTS responses in the messages list
                return;
            } else {
                messageElement.textContent = `${message.type}: ${JSON.stringify(message)}`;
            }
            
            messagesContainer.insertBefore(messageElement, messagesContainer.firstChild);
            
            // Limit the number of displayed messages
            while (messagesContainer.children.length > 20) {
                messagesContainer.removeChild(messagesContainer.lastChild);
            }
        }
        
        function updateActiveLanguage(languageCode) {
            // Remove active class from all language buttons
            document.querySelectorAll('.language-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to the selected language button
            const activeBtn = document.querySelector(`.language-btn[data-lang="${languageCode}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
            
            // Also update the categorized language UI
            updateSelectedLanguageInUI(languageCode);
        }
        
        // Update the selected language in the categorized UI
        function updateSelectedLanguageInUI(languageCode) {
            // Update simplified language dropdown
            const simplifiedLanguageSelect = document.getElementById('simplified-language-select');
            if (simplifiedLanguageSelect) {
                const option = Array.from(simplifiedLanguageSelect.options).find(opt => opt.value === languageCode);
                if (option) {
                    simplifiedLanguageSelect.value = languageCode;
                }
            }
            
            // Remove selected class from all options (for backward compatibility)
            document.querySelectorAll('.language-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            // Add selected class to the chosen language (for backward compatibility)
            const selectedOption = document.querySelector(`.language-option[data-lang="${languageCode}"]`);
            if (selectedOption) {
                selectedOption.classList.add('selected');
                
                // Make sure the parent category is expanded
                const parentContent = selectedOption.closest('.category-content');
                if (parentContent) {
                    parentContent.style.display = 'grid';
                    const parentHeader = parentContent.previousElementSibling;
                    if (parentHeader) {
                        parentHeader.classList.remove('collapsed');
                    }
                }
            }
        }
        
        function getLanguageName(code) {
            const languages = {
                'es': 'Spanish',
                'fr': 'French',
                'de': 'German',
                'it': 'Italian',
                'zh': 'Chinese',
                'ja': 'Japanese',
                'ru': 'Russian',
                'ar': 'Arabic',
                'pt': 'Portuguese',
                'ko': 'Korean'
            };
            
            return languages[code] || code;
        }
        
        // Initialize event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const connectBtn = document.getElementById('connect-btn');
            const disconnectBtn = document.getElementById('disconnect-btn');
            const languageSelect = document.getElementById('language-select');
            const currentTtsService = document.getElementById('current-tts-service');
            const refreshComparisonBtn = document.getElementById('refresh-comparison');
            
            // Add CSS for language categories and unsupported languages
            const style = document.createElement('style');
            style.textContent = `
                .language-btn.unsupported {
                    opacity: 0.6;
                    background-color: #f8f8f8;
                    border-color: #ddd;
                    cursor: not-allowed;
                }
                .language-btn.unsupported:hover {
                    background-color: #f8f8f8;
                    border-color: #ddd;
                }
                option:disabled {
                    color: #999;
                    font-style: italic;
                }
                
                /* Dropdown Language Selection */
                .dropdown-language-selection {
                    margin: 20px 0;
                    max-width: 800px;
                }
                
                .dropdown-menu {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 15px;
                    margin-bottom: 20px;
                }
                
                .language-dropdown {
                    flex: 1;
                    min-width: 200px;
                    padding: 12px 15px;
                    font-size: 1rem;
                    border: 1px solid #e0e0e0;
                    border-radius: 6px;
                    background-color: white;
                    cursor: pointer;
                    transition: all 0.2s;
                    appearance: none;
                    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
                    background-repeat: no-repeat;
                    background-position: right 15px center;
                    background-size: 15px;
                }
                
                .language-dropdown:hover, .language-dropdown:focus {
                    border-color: var(--primary-color);
                    outline: none;
                    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
                }
                
                .hidden-language-data {
                    display: none;
                }
                
                /* Language Category UI Styles */
                .language-categories {
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    margin: 20px 0;
                    max-width: 800px;
                }
                
                .category {
                    border: 1px solid #e0e0e0;
                    border-radius: 6px;
                    overflow: hidden;
                }
                
                .category-header {
                    padding: 12px 15px;
                    background-color: #f5f8ff;
                    font-weight: bold;
                    cursor: pointer;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    transition: background-color 0.2s;
                }
                
                .category-header:hover {
                    background-color: #e8f0ff;
                }
                
                .category-header::after {
                    content: '▼';
                    font-size: 12px;
                    transition: transform 0.3s;
                }
                
                .category-header.collapsed::after {
                    transform: rotate(-90deg);
                }
                
                .category-content {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                    gap: 10px;
                    padding: 15px;
                    background-color: #fafafa;
                }
                
                .language-option {
                    padding: 8px 12px;
                    background-color: white;
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    cursor: pointer;
                    transition: all 0.2s;
                    text-align: center;
                }
                
                .language-option:hover {
                    background-color: #f0f7ff;
                    border-color: #c0d6ff;
                }
                
                .language-option.selected {
                    background-color: #e0edff;
                    border-color: #7aa8ff;
                    font-weight: bold;
                }
                
                .language-option.unsupported {
                    opacity: 0.6;
                    background-color: #f8f8f8;
                    border-color: #ddd;
                    cursor: not-allowed;
                    text-decoration: line-through;
                }
                
                @media (max-width: 600px) {
                    .category-content {
                        grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
                    }
                }
            `;
            document.head.appendChild(style);
            
            // TTS service is now controlled by the teacher - initialize with default
            const defaultTtsService = 'browser'; // Default value until teacher's preference received
            
            // Initialize language support with default TTS service
            if (window.LanguageSupport) {
                window.LanguageSupport.updateDropdown(defaultTtsService);
                window.LanguageSupport.updateButtons(defaultTtsService);
            }
            
            // Setup TTS service play example buttons (for comparison only)
            document.querySelectorAll('.play-example-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const ttsService = this.getAttribute('data-service');
                    log(`Play example button clicked for TTS service: ${ttsService} (comparison only)`);
                    
                    // This is for comparison only - does NOT change the active service
                    const comparisonOnly = true;
                    
                    // Show a message that this is just for comparison
                    showSuccess(`Playing example with ${getTtsServiceName(ttsService)} (Does not change the active service)`);
                    
                    // Play the current translation with this TTS service for comparison only
                    playWithTTSService(ttsService);
                    
                    // Make it extra clear this doesn't change the active service
                    const currentServiceName = document.getElementById('current-tts-service').textContent;
                    setTimeout(() => {
                        showSuccess(`Your active TTS service remains: ${currentServiceName} (controlled by teacher)`);
                    }, 3000);
                });
            });
            
            // Set up audio comparison handling
            window.audioCache = window.audioCache || {};
            window.lastTranslationData = null;
            
            // Setup refresh comparison button
            if (refreshComparisonBtn) {
                refreshComparisonBtn.addEventListener('click', function() {
                    log('Refreshing audio comparison panel');
                    updateAudioComparison();
                    document.getElementById('audio-comparison').style.display = 'block';
                });
            }
            
            connectBtn.addEventListener('click', connectWebSocket);
            disconnectBtn.addEventListener('click', disconnectWebSocket);
            
            languageSelect.addEventListener('change', function() {
                selectedLanguage = this.value;
                if (isConnected) {
                    registerAsStudent(selectedLanguage);
                }
                
                // Update UI to reflect selected language in language categories
                updateSelectedLanguageInUI(selectedLanguage);
            });
            
            // Set up category headers to expand/collapse
            document.querySelectorAll('.category-header').forEach(header => {
                header.addEventListener('click', function(event) {
                    // Prevent click from propagating to language options
                    event.stopPropagation();
                    
                    const categoryId = this.getAttribute('data-category');
                    const content = this.nextElementSibling;
                    
                    // Toggle the collapsed class
                    this.classList.toggle('collapsed');
                    
                    // Toggle visibility
                    if (content.style.display === 'none') {
                        content.style.display = 'grid';
                    } else {
                        content.style.display = 'none';
                    }
                });
            });
            
            // Language options click handler
            document.querySelectorAll('.language-option').forEach(option => {
                option.addEventListener('click', function() {
                    const lang = this.getAttribute('data-lang');
                    
                    // Get the current teacher-controlled TTS service from the display span
                    const currentServiceName = document.getElementById('current-tts-service').textContent;
                    // Convert display name back to service ID using the helper function
                    const currentTtsService = getTtsServiceTypeFromName(currentServiceName);
                    
                    // Check if this language is supported by the current TTS service
                    if (window.LanguageSupport && !window.LanguageSupport.isSupported(lang, currentTtsService)) {
                        showError(`${this.textContent} is not supported by the current voice service (${currentServiceName}). 
                                  Please ask the teacher to change the voice service.`);
                        return;
                    }
                    
                    // Update dropdown if it exists
                    if (languageSelect) {
                        const option = Array.from(languageSelect.options).find(opt => opt.value === lang);
                        if (option) {
                            languageSelect.value = lang;
                        }
                    }
                    
                    // Update the selected language
                    selectedLanguage = lang;
                    
                    // Register with new language
                    if (isConnected) {
                        registerAsStudent(lang);
                        showSuccess(`Language changed to ${this.textContent}`);
                    }
                    
                    // Update UI to show selected language
                    updateSelectedLanguageInUI(lang);
                });
            });
            
            // No TTS service selection button handling needed anymore - teacher controls this
            
            // Quick language buttons
            document.querySelectorAll('.language-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const lang = this.getAttribute('data-lang');
                    
                    // Get the current teacher-controlled TTS service from the display span
                    const currentServiceName = document.getElementById('current-tts-service').textContent;
                    // Convert display name back to service ID using the helper function
                    const currentTtsService = getTtsServiceTypeFromName(currentServiceName);
                    
                    // Check if this language is supported by the current TTS service
                    if (window.LanguageSupport && !window.LanguageSupport.isSupported(lang, currentTtsService)) {
                        showError(`${this.textContent} is not supported by the current TTS service (${currentServiceName}). 
                                  Please ask the teacher to change the TTS service.`);
                        return;
                    }
                    
                    // Update selected language
                    languageSelect.value = lang;
                    selectedLanguage = lang;
                    
                    // Update UI
                    document.querySelectorAll('.language-btn').forEach(button => {
                        button.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    if (isConnected) {
                        registerAsStudent(lang);
                        showSuccess(`Language changed to ${this.textContent}`);
                    }
                });
            });
            
            // Initialize modal for expanded language selection
            const showMoreBtn = document.getElementById('show-more-languages');
            const closeModalBtn = document.getElementById('close-modal');
            const languageModal = document.getElementById('language-modal');
            
            if (showMoreBtn && languageModal) {
                // Initialize the expanded language list when "More Languages" is clicked
                showMoreBtn.addEventListener('click', function() {
                    // Get the current teacher-controlled TTS service from the display span
                    const currentServiceName = document.getElementById('current-tts-service').textContent;
                    // Convert display name back to service ID using the helper function
                    const currentTtsService = getTtsServiceTypeFromName(currentServiceName);
                    
                    // Use the LanguageSupport module to update the expanded list
                    if (window.LanguageSupport) {
                        window.LanguageSupport.updateExpandedList(currentTtsService);
                    }
                    
                    // Show the modal
                    languageModal.style.display = 'block';
                });
                
                // Close modal button
                if (closeModalBtn) {
                    closeModalBtn.addEventListener('click', function() {
                        languageModal.style.display = 'none';
                    });
                }
                
                // Close modal when clicking outside
                window.addEventListener('click', function(event) {
                    if (event.target === languageModal) {
                        languageModal.style.display = 'none';
                    }
                });
            }
            
            // Initialize all category contents to be visible
            document.querySelectorAll('.category-content').forEach(content => {
                content.style.display = 'grid';
            });
            
            // Initialize by showing the selected language
            if (selectedLanguage) {
                updateSelectedLanguageInUI(selectedLanguage);
            }
            
            // Set up simplified language selection
            const simplifiedLanguageSelect = document.getElementById('simplified-language-select');
            
            if (simplifiedLanguageSelect) {
                // Get current TTS service to check language support
                const currentServiceName = document.getElementById('current-tts-service').textContent;
                const currentTtsService = getTtsServiceTypeFromName(currentServiceName);
                
                // Disable languages not supported by current TTS service
                if (window.LanguageSupport) {
                    Array.from(simplifiedLanguageSelect.options).forEach(option => {
                        if (option.value && !window.LanguageSupport.isSupported(option.value, currentTtsService)) {
                            option.disabled = true;
                            option.text = option.text + ' (Not supported)';
                        }
                    });
                }
                
                // When language is selected
                simplifiedLanguageSelect.addEventListener('change', function() {
                    const lang = this.value;
                    if (!lang) return;
                    
                    // Update selected language
                    selectedLanguage = lang;
                    
                    // Update the hidden language select for backward compatibility
                    if (languageSelect) {
                        languageSelect.value = lang;
                    }
                    
                    // Register with new language if connected
                    if (isConnected) {
                        registerAsStudent(lang);
                        showSuccess(`Language changed to ${this.options[this.selectedIndex].text}`);
                    }
                    
                    // Update UI
                    updateSelectedLanguageInUI(lang);
                });
            }
            
            log('Student page initialized with categorized language options');
        });
    </script>
</body>
</html>