import { TranscriptionService, TranscriptionState, TranscriptionResult } from '../../client/src/lib/transcription/TranscriptionService';

export class MockTranscriptionService implements TranscriptionService {
  private state: TranscriptionState = 'inactive';
  private listeners: Map<string, Function[]> = new Map();
  private language: string = 'en-US';
  private shouldFailNextStart: boolean = false;
  private autoGeneratedText: string | null = null;
  private recognitionDelay: number = 500;

  public transcriptionHistory: TranscriptionResult[] = [];
  
  constructor() {
    this.reset();
  }

  public reset(): void {
    this.state = 'inactive';
    this.listeners = new Map();
    this.language = 'en-US';
    this.shouldFailNextStart = false;
    this.autoGeneratedText = null;
    this.recognitionDelay = 500;
    this.transcriptionHistory = [];
  }

  public async start(): Promise<boolean> {
    if (this.shouldFailNextStart) {
      this.shouldFailNextStart = false;
      this.state = 'error';
      this.emit('error', new Error('Failed to start transcription'));
      return false;
    }

    this.state = 'recording';
    this.emit('start');

    // If auto text is set, simulate recognition after delay
    if (this.autoGeneratedText) {
      setTimeout(() => {
        this.simulateTranscriptionResult(this.autoGeneratedText!, true);
      }, this.recognitionDelay);
    }

    return true;
  }

  public stop(): boolean {
    this.state = 'inactive';
    this.emit('stop');
    return true;
  }

  public getState(): TranscriptionState {
    return this.state;
  }

  public setLanguage(language: string): void {
    this.language = language;
  }

  public getLanguage(): string {
    return this.language;
  }

  public on(event: string, callback: Function): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event)?.push(callback);
  }

  public off(event: string, callback: Function): void {
    if (!this.listeners.has(event)) return;
    
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index !== -1) {
        callbacks.splice(index, 1);
      }
    }
  }

  private emit(event: string, ...args: any[]): void {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(...args);
        } catch (error) {
          console.error(`Error in transcription service event listener for "${event}":`, error);
        }
      });
    }
  }

  // Test control methods
  public setFailNextStart(shouldFail: boolean): void {
    this.shouldFailNextStart = shouldFail;
  }

  public setAutoGeneratedText(text: string | null): void {
    this.autoGeneratedText = text;
  }

  public setRecognitionDelay(delay: number): void {
    this.recognitionDelay = delay;
  }

  public simulateTranscriptionResult(text: string, isFinal: boolean = true): void {
    const result: TranscriptionResult = {
      text,
      isFinal,
      timestamp: Date.now(),
      language: this.language
    };
    
    this.transcriptionHistory.push(result);
    this.emit('result', result);
    
    if (isFinal) {
      this.emit('finalResult', result);
    }
  }

  public simulateError(error: Error): void {
    this.state = 'error';
    this.emit('error', error);
  }

  public simulateNoMatch(): void {
    this.emit('noMatch');
  }

  public simulateAudioStart(): void {
    this.emit('audioStart');
  }

  public simulateAudioEnd(): void {
    this.emit('audioEnd');
  }

  public simulateSpeechStart(): void {
    this.emit('speechStart');
  }

  public simulateSpeechEnd(): void {
    this.emit('speechEnd');
  }
}